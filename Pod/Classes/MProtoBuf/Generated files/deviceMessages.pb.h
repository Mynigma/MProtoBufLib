// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deviceMessages.proto

#ifndef PROTOBUF_deviceMessages_2eproto__INCLUDED
#define PROTOBUF_deviceMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mynigma {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_deviceMessages_2eproto();
void protobuf_AssignDesc_deviceMessages_2eproto();
void protobuf_ShutdownFile_deviceMessages_2eproto();

class deviceMessage;
class deviceDiscoveryPayload;
class confirmConnectionMessagePayload;
class announceInfoMessagePayload;
class digestInfoPair;
class digestInfoPart;

// ===================================================================

class deviceMessage : public ::google::protobuf::Message {
 public:
  deviceMessage();
  virtual ~deviceMessage();

  deviceMessage(const deviceMessage& from);

  inline deviceMessage& operator=(const deviceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const deviceMessage& default_instance();

  void Swap(deviceMessage* other);

  // implements Message ----------------------------------------------

  deviceMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const deviceMessage& from);
  void MergeFrom(const deviceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string messageCommand = 1;
  inline bool has_messagecommand() const;
  inline void clear_messagecommand();
  static const int kMessageCommandFieldNumber = 1;
  inline const ::std::string& messagecommand() const;
  inline void set_messagecommand(const ::std::string& value);
  inline void set_messagecommand(const char* value);
  inline void set_messagecommand(const char* value, size_t size);
  inline ::std::string* mutable_messagecommand();
  inline ::std::string* release_messagecommand();
  inline void set_allocated_messagecommand(::std::string* messagecommand);

  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional int64 sentDate = 3;
  inline bool has_sentdate() const;
  inline void clear_sentdate();
  static const int kSentDateFieldNumber = 3;
  inline ::google::protobuf::int64 sentdate() const;
  inline void set_sentdate(::google::protobuf::int64 value);

  // optional int64 expiryDate = 4;
  inline bool has_expirydate() const;
  inline void clear_expirydate();
  static const int kExpiryDateFieldNumber = 4;
  inline ::google::protobuf::int64 expirydate() const;
  inline void set_expirydate(::google::protobuf::int64 value);

  // optional bool burnAfterReading = 5;
  inline bool has_burnafterreading() const;
  inline void clear_burnafterreading();
  static const int kBurnAfterReadingFieldNumber = 5;
  inline bool burnafterreading() const;
  inline void set_burnafterreading(bool value);

  // optional string threadID = 6;
  inline bool has_threadid() const;
  inline void clear_threadid();
  static const int kThreadIDFieldNumber = 6;
  inline const ::std::string& threadid() const;
  inline void set_threadid(const ::std::string& value);
  inline void set_threadid(const char* value);
  inline void set_threadid(const char* value, size_t size);
  inline ::std::string* mutable_threadid();
  inline ::std::string* release_threadid();
  inline void set_allocated_threadid(::std::string* threadid);

  // optional string senderUUID = 7;
  inline bool has_senderuuid() const;
  inline void clear_senderuuid();
  static const int kSenderUUIDFieldNumber = 7;
  inline const ::std::string& senderuuid() const;
  inline void set_senderuuid(const ::std::string& value);
  inline void set_senderuuid(const char* value);
  inline void set_senderuuid(const char* value, size_t size);
  inline ::std::string* mutable_senderuuid();
  inline ::std::string* release_senderuuid();
  inline void set_allocated_senderuuid(::std::string* senderuuid);

  // repeated string recipientUUIDs = 8;
  inline int recipientuuids_size() const;
  inline void clear_recipientuuids();
  static const int kRecipientUUIDsFieldNumber = 8;
  inline const ::std::string& recipientuuids(int index) const;
  inline ::std::string* mutable_recipientuuids(int index);
  inline void set_recipientuuids(int index, const ::std::string& value);
  inline void set_recipientuuids(int index, const char* value);
  inline void set_recipientuuids(int index, const char* value, size_t size);
  inline ::std::string* add_recipientuuids();
  inline void add_recipientuuids(const ::std::string& value);
  inline void add_recipientuuids(const char* value);
  inline void add_recipientuuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recipientuuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recipientuuids();

  // optional string version = 9;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 9;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.deviceMessage)
 private:
  inline void set_has_messagecommand();
  inline void clear_has_messagecommand();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_sentdate();
  inline void clear_has_sentdate();
  inline void set_has_expirydate();
  inline void clear_has_expirydate();
  inline void set_has_burnafterreading();
  inline void clear_has_burnafterreading();
  inline void set_has_threadid();
  inline void clear_has_threadid();
  inline void set_has_senderuuid();
  inline void clear_has_senderuuid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* messagecommand_;
  ::std::string* payload_;
  ::google::protobuf::int64 sentdate_;
  ::google::protobuf::int64 expirydate_;
  ::std::string* threadid_;
  ::std::string* senderuuid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recipientuuids_;
  ::std::string* version_;
  bool burnafterreading_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static deviceMessage* default_instance_;
};
// -------------------------------------------------------------------

class deviceDiscoveryPayload : public ::google::protobuf::Message {
 public:
  deviceDiscoveryPayload();
  virtual ~deviceDiscoveryPayload();

  deviceDiscoveryPayload(const deviceDiscoveryPayload& from);

  inline deviceDiscoveryPayload& operator=(const deviceDiscoveryPayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const deviceDiscoveryPayload& default_instance();

  void Swap(deviceDiscoveryPayload* other);

  // implements Message ----------------------------------------------

  deviceDiscoveryPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const deviceDiscoveryPayload& from);
  void MergeFrom(const deviceDiscoveryPayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUUIDFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string emailAdresses = 4;
  inline int emailadresses_size() const;
  inline void clear_emailadresses();
  static const int kEmailAdressesFieldNumber = 4;
  inline const ::std::string& emailadresses(int index) const;
  inline ::std::string* mutable_emailadresses(int index);
  inline void set_emailadresses(int index, const ::std::string& value);
  inline void set_emailadresses(int index, const char* value);
  inline void set_emailadresses(int index, const char* value, size_t size);
  inline ::std::string* add_emailadresses();
  inline void add_emailadresses(const ::std::string& value);
  inline void add_emailadresses(const char* value);
  inline void add_emailadresses(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& emailadresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_emailadresses();

  // repeated string privateKeyLabels = 5;
  inline int privatekeylabels_size() const;
  inline void clear_privatekeylabels();
  static const int kPrivateKeyLabelsFieldNumber = 5;
  inline const ::std::string& privatekeylabels(int index) const;
  inline ::std::string* mutable_privatekeylabels(int index);
  inline void set_privatekeylabels(int index, const ::std::string& value);
  inline void set_privatekeylabels(int index, const char* value);
  inline void set_privatekeylabels(int index, const char* value, size_t size);
  inline ::std::string* add_privatekeylabels();
  inline void add_privatekeylabels(const ::std::string& value);
  inline void add_privatekeylabels(const char* value);
  inline void add_privatekeylabels(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& privatekeylabels() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_privatekeylabels();

  // optional string OSIdentifier = 6;
  inline bool has_osidentifier() const;
  inline void clear_osidentifier();
  static const int kOSIdentifierFieldNumber = 6;
  inline const ::std::string& osidentifier() const;
  inline void set_osidentifier(const ::std::string& value);
  inline void set_osidentifier(const char* value);
  inline void set_osidentifier(const char* value, size_t size);
  inline ::std::string* mutable_osidentifier();
  inline ::std::string* release_osidentifier();
  inline void set_allocated_osidentifier(::std::string* osidentifier);

  // optional string version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.deviceDiscoveryPayload)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_osidentifier();
  inline void clear_has_osidentifier();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* type_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> emailadresses_;
  ::google::protobuf::RepeatedPtrField< ::std::string> privatekeylabels_;
  ::std::string* osidentifier_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static deviceDiscoveryPayload* default_instance_;
};
// -------------------------------------------------------------------

class confirmConnectionMessagePayload : public ::google::protobuf::Message {
 public:
  confirmConnectionMessagePayload();
  virtual ~confirmConnectionMessagePayload();

  confirmConnectionMessagePayload(const confirmConnectionMessagePayload& from);

  inline confirmConnectionMessagePayload& operator=(const confirmConnectionMessagePayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const confirmConnectionMessagePayload& default_instance();

  void Swap(confirmConnectionMessagePayload* other);

  // implements Message ----------------------------------------------

  confirmConnectionMessagePayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const confirmConnectionMessagePayload& from);
  void MergeFrom(const confirmConnectionMessagePayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes secretKeyData = 1;
  inline bool has_secretkeydata() const;
  inline void clear_secretkeydata();
  static const int kSecretKeyDataFieldNumber = 1;
  inline const ::std::string& secretkeydata() const;
  inline void set_secretkeydata(const ::std::string& value);
  inline void set_secretkeydata(const char* value);
  inline void set_secretkeydata(const void* value, size_t size);
  inline ::std::string* mutable_secretkeydata();
  inline ::std::string* release_secretkeydata();
  inline void set_allocated_secretkeydata(::std::string* secretkeydata);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.confirmConnectionMessagePayload)
 private:
  inline void set_has_secretkeydata();
  inline void clear_has_secretkeydata();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* secretkeydata_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static confirmConnectionMessagePayload* default_instance_;
};
// -------------------------------------------------------------------

class announceInfoMessagePayload : public ::google::protobuf::Message {
 public:
  announceInfoMessagePayload();
  virtual ~announceInfoMessagePayload();

  announceInfoMessagePayload(const announceInfoMessagePayload& from);

  inline announceInfoMessagePayload& operator=(const announceInfoMessagePayload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const announceInfoMessagePayload& default_instance();

  void Swap(announceInfoMessagePayload* other);

  // implements Message ----------------------------------------------

  announceInfoMessagePayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const announceInfoMessagePayload& from);
  void MergeFrom(const announceInfoMessagePayload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes publicKeyVerData = 1;
  inline bool has_publickeyverdata() const;
  inline void clear_publickeyverdata();
  static const int kPublicKeyVerDataFieldNumber = 1;
  inline const ::std::string& publickeyverdata() const;
  inline void set_publickeyverdata(const ::std::string& value);
  inline void set_publickeyverdata(const char* value);
  inline void set_publickeyverdata(const void* value, size_t size);
  inline ::std::string* mutable_publickeyverdata();
  inline ::std::string* release_publickeyverdata();
  inline void set_allocated_publickeyverdata(::std::string* publickeyverdata);

  // optional bytes publicKeyEncData = 2;
  inline bool has_publickeyencdata() const;
  inline void clear_publickeyencdata();
  static const int kPublicKeyEncDataFieldNumber = 2;
  inline const ::std::string& publickeyencdata() const;
  inline void set_publickeyencdata(const ::std::string& value);
  inline void set_publickeyencdata(const char* value);
  inline void set_publickeyencdata(const void* value, size_t size);
  inline ::std::string* mutable_publickeyencdata();
  inline ::std::string* release_publickeyencdata();
  inline void set_allocated_publickeyencdata(::std::string* publickeyencdata);

  // optional string keyLabel = 3;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 3;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional bytes hashData = 4;
  inline bool has_hashdata() const;
  inline void clear_hashdata();
  static const int kHashDataFieldNumber = 4;
  inline const ::std::string& hashdata() const;
  inline void set_hashdata(const ::std::string& value);
  inline void set_hashdata(const char* value);
  inline void set_hashdata(const void* value, size_t size);
  inline ::std::string* mutable_hashdata();
  inline ::std::string* release_hashdata();
  inline void set_allocated_hashdata(::std::string* hashdata);

  // optional bytes deviceDiscoveryPayloadData = 5;
  inline bool has_devicediscoverypayloaddata() const;
  inline void clear_devicediscoverypayloaddata();
  static const int kDeviceDiscoveryPayloadDataFieldNumber = 5;
  inline const ::std::string& devicediscoverypayloaddata() const;
  inline void set_devicediscoverypayloaddata(const ::std::string& value);
  inline void set_devicediscoverypayloaddata(const char* value);
  inline void set_devicediscoverypayloaddata(const void* value, size_t size);
  inline ::std::string* mutable_devicediscoverypayloaddata();
  inline ::std::string* release_devicediscoverypayloaddata();
  inline void set_allocated_devicediscoverypayloaddata(::std::string* devicediscoverypayloaddata);

  // optional string version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:mynigma.announceInfoMessagePayload)
 private:
  inline void set_has_publickeyverdata();
  inline void clear_has_publickeyverdata();
  inline void set_has_publickeyencdata();
  inline void clear_has_publickeyencdata();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_hashdata();
  inline void clear_has_hashdata();
  inline void set_has_devicediscoverypayloaddata();
  inline void clear_has_devicediscoverypayloaddata();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publickeyverdata_;
  ::std::string* publickeyencdata_;
  ::std::string* keylabel_;
  ::std::string* hashdata_;
  ::std::string* devicediscoverypayloaddata_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static announceInfoMessagePayload* default_instance_;
};
// -------------------------------------------------------------------

class digestInfoPair : public ::google::protobuf::Message {
 public:
  digestInfoPair();
  virtual ~digestInfoPair();

  digestInfoPair(const digestInfoPair& from);

  inline digestInfoPair& operator=(const digestInfoPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const digestInfoPair& default_instance();

  void Swap(digestInfoPair* other);

  // implements Message ----------------------------------------------

  digestInfoPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const digestInfoPair& from);
  void MergeFrom(const digestInfoPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mynigma.digestInfoPart initiatorDigestData = 1;
  inline bool has_initiatordigestdata() const;
  inline void clear_initiatordigestdata();
  static const int kInitiatorDigestDataFieldNumber = 1;
  inline const ::mynigma::digestInfoPart& initiatordigestdata() const;
  inline ::mynigma::digestInfoPart* mutable_initiatordigestdata();
  inline ::mynigma::digestInfoPart* release_initiatordigestdata();
  inline void set_allocated_initiatordigestdata(::mynigma::digestInfoPart* initiatordigestdata);

  // optional .mynigma.digestInfoPart responderDigestData = 2;
  inline bool has_responderdigestdata() const;
  inline void clear_responderdigestdata();
  static const int kResponderDigestDataFieldNumber = 2;
  inline const ::mynigma::digestInfoPart& responderdigestdata() const;
  inline ::mynigma::digestInfoPart* mutable_responderdigestdata();
  inline ::mynigma::digestInfoPart* release_responderdigestdata();
  inline void set_allocated_responderdigestdata(::mynigma::digestInfoPart* responderdigestdata);

  // @@protoc_insertion_point(class_scope:mynigma.digestInfoPair)
 private:
  inline void set_has_initiatordigestdata();
  inline void clear_has_initiatordigestdata();
  inline void set_has_responderdigestdata();
  inline void clear_has_responderdigestdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mynigma::digestInfoPart* initiatordigestdata_;
  ::mynigma::digestInfoPart* responderdigestdata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static digestInfoPair* default_instance_;
};
// -------------------------------------------------------------------

class digestInfoPart : public ::google::protobuf::Message {
 public:
  digestInfoPart();
  virtual ~digestInfoPart();

  digestInfoPart(const digestInfoPart& from);

  inline digestInfoPart& operator=(const digestInfoPart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const digestInfoPart& default_instance();

  void Swap(digestInfoPart* other);

  // implements Message ----------------------------------------------

  digestInfoPart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const digestInfoPart& from);
  void MergeFrom(const digestInfoPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes publicVerKeyData = 1;
  inline bool has_publicverkeydata() const;
  inline void clear_publicverkeydata();
  static const int kPublicVerKeyDataFieldNumber = 1;
  inline const ::std::string& publicverkeydata() const;
  inline void set_publicverkeydata(const ::std::string& value);
  inline void set_publicverkeydata(const char* value);
  inline void set_publicverkeydata(const void* value, size_t size);
  inline ::std::string* mutable_publicverkeydata();
  inline ::std::string* release_publicverkeydata();
  inline void set_allocated_publicverkeydata(::std::string* publicverkeydata);

  // optional bytes publicEncKeyData = 2;
  inline bool has_publicenckeydata() const;
  inline void clear_publicenckeydata();
  static const int kPublicEncKeyDataFieldNumber = 2;
  inline const ::std::string& publicenckeydata() const;
  inline void set_publicenckeydata(const ::std::string& value);
  inline void set_publicenckeydata(const char* value);
  inline void set_publicenckeydata(const void* value, size_t size);
  inline ::std::string* mutable_publicenckeydata();
  inline ::std::string* release_publicenckeydata();
  inline void set_allocated_publicenckeydata(::std::string* publicenckeydata);

  // optional bytes secretData = 3;
  inline bool has_secretdata() const;
  inline void clear_secretdata();
  static const int kSecretDataFieldNumber = 3;
  inline const ::std::string& secretdata() const;
  inline void set_secretdata(const ::std::string& value);
  inline void set_secretdata(const char* value);
  inline void set_secretdata(const void* value, size_t size);
  inline ::std::string* mutable_secretdata();
  inline ::std::string* release_secretdata();
  inline void set_allocated_secretdata(::std::string* secretdata);

  // optional string deviceUUID = 4;
  inline bool has_deviceuuid() const;
  inline void clear_deviceuuid();
  static const int kDeviceUUIDFieldNumber = 4;
  inline const ::std::string& deviceuuid() const;
  inline void set_deviceuuid(const ::std::string& value);
  inline void set_deviceuuid(const char* value);
  inline void set_deviceuuid(const char* value, size_t size);
  inline ::std::string* mutable_deviceuuid();
  inline ::std::string* release_deviceuuid();
  inline void set_allocated_deviceuuid(::std::string* deviceuuid);

  // optional string deviceKeyLabel = 5;
  inline bool has_devicekeylabel() const;
  inline void clear_devicekeylabel();
  static const int kDeviceKeyLabelFieldNumber = 5;
  inline const ::std::string& devicekeylabel() const;
  inline void set_devicekeylabel(const ::std::string& value);
  inline void set_devicekeylabel(const char* value);
  inline void set_devicekeylabel(const char* value, size_t size);
  inline ::std::string* mutable_devicekeylabel();
  inline ::std::string* release_devicekeylabel();
  inline void set_allocated_devicekeylabel(::std::string* devicekeylabel);

  // @@protoc_insertion_point(class_scope:mynigma.digestInfoPart)
 private:
  inline void set_has_publicverkeydata();
  inline void clear_has_publicverkeydata();
  inline void set_has_publicenckeydata();
  inline void clear_has_publicenckeydata();
  inline void set_has_secretdata();
  inline void clear_has_secretdata();
  inline void set_has_deviceuuid();
  inline void clear_has_deviceuuid();
  inline void set_has_devicekeylabel();
  inline void clear_has_devicekeylabel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publicverkeydata_;
  ::std::string* publicenckeydata_;
  ::std::string* secretdata_;
  ::std::string* deviceuuid_;
  ::std::string* devicekeylabel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_deviceMessages_2eproto();
  friend void protobuf_AssignDesc_deviceMessages_2eproto();
  friend void protobuf_ShutdownFile_deviceMessages_2eproto();

  void InitAsDefaultInstance();
  static digestInfoPart* default_instance_;
};
// ===================================================================


// ===================================================================

// deviceMessage

// optional string messageCommand = 1;
inline bool deviceMessage::has_messagecommand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void deviceMessage::set_has_messagecommand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void deviceMessage::clear_has_messagecommand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void deviceMessage::clear_messagecommand() {
  if (messagecommand_ != &::google::protobuf::internal::kEmptyString) {
    messagecommand_->clear();
  }
  clear_has_messagecommand();
}
inline const ::std::string& deviceMessage::messagecommand() const {
  return *messagecommand_;
}
inline void deviceMessage::set_messagecommand(const ::std::string& value) {
  set_has_messagecommand();
  if (messagecommand_ == &::google::protobuf::internal::kEmptyString) {
    messagecommand_ = new ::std::string;
  }
  messagecommand_->assign(value);
}
inline void deviceMessage::set_messagecommand(const char* value) {
  set_has_messagecommand();
  if (messagecommand_ == &::google::protobuf::internal::kEmptyString) {
    messagecommand_ = new ::std::string;
  }
  messagecommand_->assign(value);
}
inline void deviceMessage::set_messagecommand(const char* value, size_t size) {
  set_has_messagecommand();
  if (messagecommand_ == &::google::protobuf::internal::kEmptyString) {
    messagecommand_ = new ::std::string;
  }
  messagecommand_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::mutable_messagecommand() {
  set_has_messagecommand();
  if (messagecommand_ == &::google::protobuf::internal::kEmptyString) {
    messagecommand_ = new ::std::string;
  }
  return messagecommand_;
}
inline ::std::string* deviceMessage::release_messagecommand() {
  clear_has_messagecommand();
  if (messagecommand_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagecommand_;
    messagecommand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceMessage::set_allocated_messagecommand(::std::string* messagecommand) {
  if (messagecommand_ != &::google::protobuf::internal::kEmptyString) {
    delete messagecommand_;
  }
  if (messagecommand) {
    set_has_messagecommand();
    messagecommand_ = messagecommand;
  } else {
    clear_has_messagecommand();
    messagecommand_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes payload = 2;
inline bool deviceMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void deviceMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void deviceMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void deviceMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& deviceMessage::payload() const {
  return *payload_;
}
inline void deviceMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void deviceMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void deviceMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* deviceMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sentDate = 3;
inline bool deviceMessage::has_sentdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void deviceMessage::set_has_sentdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void deviceMessage::clear_has_sentdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void deviceMessage::clear_sentdate() {
  sentdate_ = GOOGLE_LONGLONG(0);
  clear_has_sentdate();
}
inline ::google::protobuf::int64 deviceMessage::sentdate() const {
  return sentdate_;
}
inline void deviceMessage::set_sentdate(::google::protobuf::int64 value) {
  set_has_sentdate();
  sentdate_ = value;
}

// optional int64 expiryDate = 4;
inline bool deviceMessage::has_expirydate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void deviceMessage::set_has_expirydate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void deviceMessage::clear_has_expirydate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void deviceMessage::clear_expirydate() {
  expirydate_ = GOOGLE_LONGLONG(0);
  clear_has_expirydate();
}
inline ::google::protobuf::int64 deviceMessage::expirydate() const {
  return expirydate_;
}
inline void deviceMessage::set_expirydate(::google::protobuf::int64 value) {
  set_has_expirydate();
  expirydate_ = value;
}

// optional bool burnAfterReading = 5;
inline bool deviceMessage::has_burnafterreading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void deviceMessage::set_has_burnafterreading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void deviceMessage::clear_has_burnafterreading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void deviceMessage::clear_burnafterreading() {
  burnafterreading_ = false;
  clear_has_burnafterreading();
}
inline bool deviceMessage::burnafterreading() const {
  return burnafterreading_;
}
inline void deviceMessage::set_burnafterreading(bool value) {
  set_has_burnafterreading();
  burnafterreading_ = value;
}

// optional string threadID = 6;
inline bool deviceMessage::has_threadid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void deviceMessage::set_has_threadid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void deviceMessage::clear_has_threadid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void deviceMessage::clear_threadid() {
  if (threadid_ != &::google::protobuf::internal::kEmptyString) {
    threadid_->clear();
  }
  clear_has_threadid();
}
inline const ::std::string& deviceMessage::threadid() const {
  return *threadid_;
}
inline void deviceMessage::set_threadid(const ::std::string& value) {
  set_has_threadid();
  if (threadid_ == &::google::protobuf::internal::kEmptyString) {
    threadid_ = new ::std::string;
  }
  threadid_->assign(value);
}
inline void deviceMessage::set_threadid(const char* value) {
  set_has_threadid();
  if (threadid_ == &::google::protobuf::internal::kEmptyString) {
    threadid_ = new ::std::string;
  }
  threadid_->assign(value);
}
inline void deviceMessage::set_threadid(const char* value, size_t size) {
  set_has_threadid();
  if (threadid_ == &::google::protobuf::internal::kEmptyString) {
    threadid_ = new ::std::string;
  }
  threadid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::mutable_threadid() {
  set_has_threadid();
  if (threadid_ == &::google::protobuf::internal::kEmptyString) {
    threadid_ = new ::std::string;
  }
  return threadid_;
}
inline ::std::string* deviceMessage::release_threadid() {
  clear_has_threadid();
  if (threadid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = threadid_;
    threadid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceMessage::set_allocated_threadid(::std::string* threadid) {
  if (threadid_ != &::google::protobuf::internal::kEmptyString) {
    delete threadid_;
  }
  if (threadid) {
    set_has_threadid();
    threadid_ = threadid;
  } else {
    clear_has_threadid();
    threadid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string senderUUID = 7;
inline bool deviceMessage::has_senderuuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void deviceMessage::set_has_senderuuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void deviceMessage::clear_has_senderuuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void deviceMessage::clear_senderuuid() {
  if (senderuuid_ != &::google::protobuf::internal::kEmptyString) {
    senderuuid_->clear();
  }
  clear_has_senderuuid();
}
inline const ::std::string& deviceMessage::senderuuid() const {
  return *senderuuid_;
}
inline void deviceMessage::set_senderuuid(const ::std::string& value) {
  set_has_senderuuid();
  if (senderuuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuuid_ = new ::std::string;
  }
  senderuuid_->assign(value);
}
inline void deviceMessage::set_senderuuid(const char* value) {
  set_has_senderuuid();
  if (senderuuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuuid_ = new ::std::string;
  }
  senderuuid_->assign(value);
}
inline void deviceMessage::set_senderuuid(const char* value, size_t size) {
  set_has_senderuuid();
  if (senderuuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuuid_ = new ::std::string;
  }
  senderuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::mutable_senderuuid() {
  set_has_senderuuid();
  if (senderuuid_ == &::google::protobuf::internal::kEmptyString) {
    senderuuid_ = new ::std::string;
  }
  return senderuuid_;
}
inline ::std::string* deviceMessage::release_senderuuid() {
  clear_has_senderuuid();
  if (senderuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = senderuuid_;
    senderuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceMessage::set_allocated_senderuuid(::std::string* senderuuid) {
  if (senderuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete senderuuid_;
  }
  if (senderuuid) {
    set_has_senderuuid();
    senderuuid_ = senderuuid;
  } else {
    clear_has_senderuuid();
    senderuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string recipientUUIDs = 8;
inline int deviceMessage::recipientuuids_size() const {
  return recipientuuids_.size();
}
inline void deviceMessage::clear_recipientuuids() {
  recipientuuids_.Clear();
}
inline const ::std::string& deviceMessage::recipientuuids(int index) const {
  return recipientuuids_.Get(index);
}
inline ::std::string* deviceMessage::mutable_recipientuuids(int index) {
  return recipientuuids_.Mutable(index);
}
inline void deviceMessage::set_recipientuuids(int index, const ::std::string& value) {
  recipientuuids_.Mutable(index)->assign(value);
}
inline void deviceMessage::set_recipientuuids(int index, const char* value) {
  recipientuuids_.Mutable(index)->assign(value);
}
inline void deviceMessage::set_recipientuuids(int index, const char* value, size_t size) {
  recipientuuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::add_recipientuuids() {
  return recipientuuids_.Add();
}
inline void deviceMessage::add_recipientuuids(const ::std::string& value) {
  recipientuuids_.Add()->assign(value);
}
inline void deviceMessage::add_recipientuuids(const char* value) {
  recipientuuids_.Add()->assign(value);
}
inline void deviceMessage::add_recipientuuids(const char* value, size_t size) {
  recipientuuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
deviceMessage::recipientuuids() const {
  return recipientuuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
deviceMessage::mutable_recipientuuids() {
  return &recipientuuids_;
}

// optional string version = 9;
inline bool deviceMessage::has_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void deviceMessage::set_has_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void deviceMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void deviceMessage::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& deviceMessage::version() const {
  return *version_;
}
inline void deviceMessage::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void deviceMessage::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void deviceMessage::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceMessage::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* deviceMessage::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceMessage::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// deviceDiscoveryPayload

// optional string UUID = 1;
inline bool deviceDiscoveryPayload::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void deviceDiscoveryPayload::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void deviceDiscoveryPayload::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void deviceDiscoveryPayload::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& deviceDiscoveryPayload::uuid() const {
  return *uuid_;
}
inline void deviceDiscoveryPayload::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void deviceDiscoveryPayload::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void deviceDiscoveryPayload::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* deviceDiscoveryPayload::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryPayload::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool deviceDiscoveryPayload::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void deviceDiscoveryPayload::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void deviceDiscoveryPayload::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void deviceDiscoveryPayload::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& deviceDiscoveryPayload::type() const {
  return *type_;
}
inline void deviceDiscoveryPayload::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void deviceDiscoveryPayload::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void deviceDiscoveryPayload::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* deviceDiscoveryPayload::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryPayload::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool deviceDiscoveryPayload::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void deviceDiscoveryPayload::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void deviceDiscoveryPayload::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void deviceDiscoveryPayload::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& deviceDiscoveryPayload::name() const {
  return *name_;
}
inline void deviceDiscoveryPayload::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void deviceDiscoveryPayload::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void deviceDiscoveryPayload::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* deviceDiscoveryPayload::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryPayload::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string emailAdresses = 4;
inline int deviceDiscoveryPayload::emailadresses_size() const {
  return emailadresses_.size();
}
inline void deviceDiscoveryPayload::clear_emailadresses() {
  emailadresses_.Clear();
}
inline const ::std::string& deviceDiscoveryPayload::emailadresses(int index) const {
  return emailadresses_.Get(index);
}
inline ::std::string* deviceDiscoveryPayload::mutable_emailadresses(int index) {
  return emailadresses_.Mutable(index);
}
inline void deviceDiscoveryPayload::set_emailadresses(int index, const ::std::string& value) {
  emailadresses_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryPayload::set_emailadresses(int index, const char* value) {
  emailadresses_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryPayload::set_emailadresses(int index, const char* value, size_t size) {
  emailadresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::add_emailadresses() {
  return emailadresses_.Add();
}
inline void deviceDiscoveryPayload::add_emailadresses(const ::std::string& value) {
  emailadresses_.Add()->assign(value);
}
inline void deviceDiscoveryPayload::add_emailadresses(const char* value) {
  emailadresses_.Add()->assign(value);
}
inline void deviceDiscoveryPayload::add_emailadresses(const char* value, size_t size) {
  emailadresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
deviceDiscoveryPayload::emailadresses() const {
  return emailadresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
deviceDiscoveryPayload::mutable_emailadresses() {
  return &emailadresses_;
}

// repeated string privateKeyLabels = 5;
inline int deviceDiscoveryPayload::privatekeylabels_size() const {
  return privatekeylabels_.size();
}
inline void deviceDiscoveryPayload::clear_privatekeylabels() {
  privatekeylabels_.Clear();
}
inline const ::std::string& deviceDiscoveryPayload::privatekeylabels(int index) const {
  return privatekeylabels_.Get(index);
}
inline ::std::string* deviceDiscoveryPayload::mutable_privatekeylabels(int index) {
  return privatekeylabels_.Mutable(index);
}
inline void deviceDiscoveryPayload::set_privatekeylabels(int index, const ::std::string& value) {
  privatekeylabels_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryPayload::set_privatekeylabels(int index, const char* value) {
  privatekeylabels_.Mutable(index)->assign(value);
}
inline void deviceDiscoveryPayload::set_privatekeylabels(int index, const char* value, size_t size) {
  privatekeylabels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::add_privatekeylabels() {
  return privatekeylabels_.Add();
}
inline void deviceDiscoveryPayload::add_privatekeylabels(const ::std::string& value) {
  privatekeylabels_.Add()->assign(value);
}
inline void deviceDiscoveryPayload::add_privatekeylabels(const char* value) {
  privatekeylabels_.Add()->assign(value);
}
inline void deviceDiscoveryPayload::add_privatekeylabels(const char* value, size_t size) {
  privatekeylabels_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
deviceDiscoveryPayload::privatekeylabels() const {
  return privatekeylabels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
deviceDiscoveryPayload::mutable_privatekeylabels() {
  return &privatekeylabels_;
}

// optional string OSIdentifier = 6;
inline bool deviceDiscoveryPayload::has_osidentifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void deviceDiscoveryPayload::set_has_osidentifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void deviceDiscoveryPayload::clear_has_osidentifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void deviceDiscoveryPayload::clear_osidentifier() {
  if (osidentifier_ != &::google::protobuf::internal::kEmptyString) {
    osidentifier_->clear();
  }
  clear_has_osidentifier();
}
inline const ::std::string& deviceDiscoveryPayload::osidentifier() const {
  return *osidentifier_;
}
inline void deviceDiscoveryPayload::set_osidentifier(const ::std::string& value) {
  set_has_osidentifier();
  if (osidentifier_ == &::google::protobuf::internal::kEmptyString) {
    osidentifier_ = new ::std::string;
  }
  osidentifier_->assign(value);
}
inline void deviceDiscoveryPayload::set_osidentifier(const char* value) {
  set_has_osidentifier();
  if (osidentifier_ == &::google::protobuf::internal::kEmptyString) {
    osidentifier_ = new ::std::string;
  }
  osidentifier_->assign(value);
}
inline void deviceDiscoveryPayload::set_osidentifier(const char* value, size_t size) {
  set_has_osidentifier();
  if (osidentifier_ == &::google::protobuf::internal::kEmptyString) {
    osidentifier_ = new ::std::string;
  }
  osidentifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::mutable_osidentifier() {
  set_has_osidentifier();
  if (osidentifier_ == &::google::protobuf::internal::kEmptyString) {
    osidentifier_ = new ::std::string;
  }
  return osidentifier_;
}
inline ::std::string* deviceDiscoveryPayload::release_osidentifier() {
  clear_has_osidentifier();
  if (osidentifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osidentifier_;
    osidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryPayload::set_allocated_osidentifier(::std::string* osidentifier) {
  if (osidentifier_ != &::google::protobuf::internal::kEmptyString) {
    delete osidentifier_;
  }
  if (osidentifier) {
    set_has_osidentifier();
    osidentifier_ = osidentifier;
  } else {
    clear_has_osidentifier();
    osidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 7;
inline bool deviceDiscoveryPayload::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void deviceDiscoveryPayload::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void deviceDiscoveryPayload::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void deviceDiscoveryPayload::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& deviceDiscoveryPayload::version() const {
  return *version_;
}
inline void deviceDiscoveryPayload::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void deviceDiscoveryPayload::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void deviceDiscoveryPayload::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* deviceDiscoveryPayload::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* deviceDiscoveryPayload::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void deviceDiscoveryPayload::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// confirmConnectionMessagePayload

// optional bytes secretKeyData = 1;
inline bool confirmConnectionMessagePayload::has_secretkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void confirmConnectionMessagePayload::set_has_secretkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void confirmConnectionMessagePayload::clear_has_secretkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void confirmConnectionMessagePayload::clear_secretkeydata() {
  if (secretkeydata_ != &::google::protobuf::internal::kEmptyString) {
    secretkeydata_->clear();
  }
  clear_has_secretkeydata();
}
inline const ::std::string& confirmConnectionMessagePayload::secretkeydata() const {
  return *secretkeydata_;
}
inline void confirmConnectionMessagePayload::set_secretkeydata(const ::std::string& value) {
  set_has_secretkeydata();
  if (secretkeydata_ == &::google::protobuf::internal::kEmptyString) {
    secretkeydata_ = new ::std::string;
  }
  secretkeydata_->assign(value);
}
inline void confirmConnectionMessagePayload::set_secretkeydata(const char* value) {
  set_has_secretkeydata();
  if (secretkeydata_ == &::google::protobuf::internal::kEmptyString) {
    secretkeydata_ = new ::std::string;
  }
  secretkeydata_->assign(value);
}
inline void confirmConnectionMessagePayload::set_secretkeydata(const void* value, size_t size) {
  set_has_secretkeydata();
  if (secretkeydata_ == &::google::protobuf::internal::kEmptyString) {
    secretkeydata_ = new ::std::string;
  }
  secretkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* confirmConnectionMessagePayload::mutable_secretkeydata() {
  set_has_secretkeydata();
  if (secretkeydata_ == &::google::protobuf::internal::kEmptyString) {
    secretkeydata_ = new ::std::string;
  }
  return secretkeydata_;
}
inline ::std::string* confirmConnectionMessagePayload::release_secretkeydata() {
  clear_has_secretkeydata();
  if (secretkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkeydata_;
    secretkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void confirmConnectionMessagePayload::set_allocated_secretkeydata(::std::string* secretkeydata) {
  if (secretkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete secretkeydata_;
  }
  if (secretkeydata) {
    set_has_secretkeydata();
    secretkeydata_ = secretkeydata;
  } else {
    clear_has_secretkeydata();
    secretkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 2;
inline bool confirmConnectionMessagePayload::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void confirmConnectionMessagePayload::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void confirmConnectionMessagePayload::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void confirmConnectionMessagePayload::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& confirmConnectionMessagePayload::version() const {
  return *version_;
}
inline void confirmConnectionMessagePayload::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void confirmConnectionMessagePayload::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void confirmConnectionMessagePayload::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* confirmConnectionMessagePayload::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* confirmConnectionMessagePayload::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void confirmConnectionMessagePayload::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// announceInfoMessagePayload

// optional bytes publicKeyVerData = 1;
inline bool announceInfoMessagePayload::has_publickeyverdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void announceInfoMessagePayload::set_has_publickeyverdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void announceInfoMessagePayload::clear_has_publickeyverdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void announceInfoMessagePayload::clear_publickeyverdata() {
  if (publickeyverdata_ != &::google::protobuf::internal::kEmptyString) {
    publickeyverdata_->clear();
  }
  clear_has_publickeyverdata();
}
inline const ::std::string& announceInfoMessagePayload::publickeyverdata() const {
  return *publickeyverdata_;
}
inline void announceInfoMessagePayload::set_publickeyverdata(const ::std::string& value) {
  set_has_publickeyverdata();
  if (publickeyverdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyverdata_ = new ::std::string;
  }
  publickeyverdata_->assign(value);
}
inline void announceInfoMessagePayload::set_publickeyverdata(const char* value) {
  set_has_publickeyverdata();
  if (publickeyverdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyverdata_ = new ::std::string;
  }
  publickeyverdata_->assign(value);
}
inline void announceInfoMessagePayload::set_publickeyverdata(const void* value, size_t size) {
  set_has_publickeyverdata();
  if (publickeyverdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyverdata_ = new ::std::string;
  }
  publickeyverdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_publickeyverdata() {
  set_has_publickeyverdata();
  if (publickeyverdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyverdata_ = new ::std::string;
  }
  return publickeyverdata_;
}
inline ::std::string* announceInfoMessagePayload::release_publickeyverdata() {
  clear_has_publickeyverdata();
  if (publickeyverdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickeyverdata_;
    publickeyverdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_publickeyverdata(::std::string* publickeyverdata) {
  if (publickeyverdata_ != &::google::protobuf::internal::kEmptyString) {
    delete publickeyverdata_;
  }
  if (publickeyverdata) {
    set_has_publickeyverdata();
    publickeyverdata_ = publickeyverdata;
  } else {
    clear_has_publickeyverdata();
    publickeyverdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes publicKeyEncData = 2;
inline bool announceInfoMessagePayload::has_publickeyencdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void announceInfoMessagePayload::set_has_publickeyencdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void announceInfoMessagePayload::clear_has_publickeyencdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void announceInfoMessagePayload::clear_publickeyencdata() {
  if (publickeyencdata_ != &::google::protobuf::internal::kEmptyString) {
    publickeyencdata_->clear();
  }
  clear_has_publickeyencdata();
}
inline const ::std::string& announceInfoMessagePayload::publickeyencdata() const {
  return *publickeyencdata_;
}
inline void announceInfoMessagePayload::set_publickeyencdata(const ::std::string& value) {
  set_has_publickeyencdata();
  if (publickeyencdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyencdata_ = new ::std::string;
  }
  publickeyencdata_->assign(value);
}
inline void announceInfoMessagePayload::set_publickeyencdata(const char* value) {
  set_has_publickeyencdata();
  if (publickeyencdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyencdata_ = new ::std::string;
  }
  publickeyencdata_->assign(value);
}
inline void announceInfoMessagePayload::set_publickeyencdata(const void* value, size_t size) {
  set_has_publickeyencdata();
  if (publickeyencdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyencdata_ = new ::std::string;
  }
  publickeyencdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_publickeyencdata() {
  set_has_publickeyencdata();
  if (publickeyencdata_ == &::google::protobuf::internal::kEmptyString) {
    publickeyencdata_ = new ::std::string;
  }
  return publickeyencdata_;
}
inline ::std::string* announceInfoMessagePayload::release_publickeyencdata() {
  clear_has_publickeyencdata();
  if (publickeyencdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickeyencdata_;
    publickeyencdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_publickeyencdata(::std::string* publickeyencdata) {
  if (publickeyencdata_ != &::google::protobuf::internal::kEmptyString) {
    delete publickeyencdata_;
  }
  if (publickeyencdata) {
    set_has_publickeyencdata();
    publickeyencdata_ = publickeyencdata;
  } else {
    clear_has_publickeyencdata();
    publickeyencdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string keyLabel = 3;
inline bool announceInfoMessagePayload::has_keylabel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void announceInfoMessagePayload::set_has_keylabel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void announceInfoMessagePayload::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void announceInfoMessagePayload::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& announceInfoMessagePayload::keylabel() const {
  return *keylabel_;
}
inline void announceInfoMessagePayload::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void announceInfoMessagePayload::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void announceInfoMessagePayload::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* announceInfoMessagePayload::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes hashData = 4;
inline bool announceInfoMessagePayload::has_hashdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void announceInfoMessagePayload::set_has_hashdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void announceInfoMessagePayload::clear_has_hashdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void announceInfoMessagePayload::clear_hashdata() {
  if (hashdata_ != &::google::protobuf::internal::kEmptyString) {
    hashdata_->clear();
  }
  clear_has_hashdata();
}
inline const ::std::string& announceInfoMessagePayload::hashdata() const {
  return *hashdata_;
}
inline void announceInfoMessagePayload::set_hashdata(const ::std::string& value) {
  set_has_hashdata();
  if (hashdata_ == &::google::protobuf::internal::kEmptyString) {
    hashdata_ = new ::std::string;
  }
  hashdata_->assign(value);
}
inline void announceInfoMessagePayload::set_hashdata(const char* value) {
  set_has_hashdata();
  if (hashdata_ == &::google::protobuf::internal::kEmptyString) {
    hashdata_ = new ::std::string;
  }
  hashdata_->assign(value);
}
inline void announceInfoMessagePayload::set_hashdata(const void* value, size_t size) {
  set_has_hashdata();
  if (hashdata_ == &::google::protobuf::internal::kEmptyString) {
    hashdata_ = new ::std::string;
  }
  hashdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_hashdata() {
  set_has_hashdata();
  if (hashdata_ == &::google::protobuf::internal::kEmptyString) {
    hashdata_ = new ::std::string;
  }
  return hashdata_;
}
inline ::std::string* announceInfoMessagePayload::release_hashdata() {
  clear_has_hashdata();
  if (hashdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hashdata_;
    hashdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_hashdata(::std::string* hashdata) {
  if (hashdata_ != &::google::protobuf::internal::kEmptyString) {
    delete hashdata_;
  }
  if (hashdata) {
    set_has_hashdata();
    hashdata_ = hashdata;
  } else {
    clear_has_hashdata();
    hashdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes deviceDiscoveryPayloadData = 5;
inline bool announceInfoMessagePayload::has_devicediscoverypayloaddata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void announceInfoMessagePayload::set_has_devicediscoverypayloaddata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void announceInfoMessagePayload::clear_has_devicediscoverypayloaddata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void announceInfoMessagePayload::clear_devicediscoverypayloaddata() {
  if (devicediscoverypayloaddata_ != &::google::protobuf::internal::kEmptyString) {
    devicediscoverypayloaddata_->clear();
  }
  clear_has_devicediscoverypayloaddata();
}
inline const ::std::string& announceInfoMessagePayload::devicediscoverypayloaddata() const {
  return *devicediscoverypayloaddata_;
}
inline void announceInfoMessagePayload::set_devicediscoverypayloaddata(const ::std::string& value) {
  set_has_devicediscoverypayloaddata();
  if (devicediscoverypayloaddata_ == &::google::protobuf::internal::kEmptyString) {
    devicediscoverypayloaddata_ = new ::std::string;
  }
  devicediscoverypayloaddata_->assign(value);
}
inline void announceInfoMessagePayload::set_devicediscoverypayloaddata(const char* value) {
  set_has_devicediscoverypayloaddata();
  if (devicediscoverypayloaddata_ == &::google::protobuf::internal::kEmptyString) {
    devicediscoverypayloaddata_ = new ::std::string;
  }
  devicediscoverypayloaddata_->assign(value);
}
inline void announceInfoMessagePayload::set_devicediscoverypayloaddata(const void* value, size_t size) {
  set_has_devicediscoverypayloaddata();
  if (devicediscoverypayloaddata_ == &::google::protobuf::internal::kEmptyString) {
    devicediscoverypayloaddata_ = new ::std::string;
  }
  devicediscoverypayloaddata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_devicediscoverypayloaddata() {
  set_has_devicediscoverypayloaddata();
  if (devicediscoverypayloaddata_ == &::google::protobuf::internal::kEmptyString) {
    devicediscoverypayloaddata_ = new ::std::string;
  }
  return devicediscoverypayloaddata_;
}
inline ::std::string* announceInfoMessagePayload::release_devicediscoverypayloaddata() {
  clear_has_devicediscoverypayloaddata();
  if (devicediscoverypayloaddata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicediscoverypayloaddata_;
    devicediscoverypayloaddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_devicediscoverypayloaddata(::std::string* devicediscoverypayloaddata) {
  if (devicediscoverypayloaddata_ != &::google::protobuf::internal::kEmptyString) {
    delete devicediscoverypayloaddata_;
  }
  if (devicediscoverypayloaddata) {
    set_has_devicediscoverypayloaddata();
    devicediscoverypayloaddata_ = devicediscoverypayloaddata;
  } else {
    clear_has_devicediscoverypayloaddata();
    devicediscoverypayloaddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 6;
inline bool announceInfoMessagePayload::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void announceInfoMessagePayload::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void announceInfoMessagePayload::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void announceInfoMessagePayload::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& announceInfoMessagePayload::version() const {
  return *version_;
}
inline void announceInfoMessagePayload::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void announceInfoMessagePayload::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void announceInfoMessagePayload::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* announceInfoMessagePayload::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* announceInfoMessagePayload::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void announceInfoMessagePayload::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// digestInfoPair

// optional .mynigma.digestInfoPart initiatorDigestData = 1;
inline bool digestInfoPair::has_initiatordigestdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void digestInfoPair::set_has_initiatordigestdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void digestInfoPair::clear_has_initiatordigestdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void digestInfoPair::clear_initiatordigestdata() {
  if (initiatordigestdata_ != NULL) initiatordigestdata_->::mynigma::digestInfoPart::Clear();
  clear_has_initiatordigestdata();
}
inline const ::mynigma::digestInfoPart& digestInfoPair::initiatordigestdata() const {
  return initiatordigestdata_ != NULL ? *initiatordigestdata_ : *default_instance_->initiatordigestdata_;
}
inline ::mynigma::digestInfoPart* digestInfoPair::mutable_initiatordigestdata() {
  set_has_initiatordigestdata();
  if (initiatordigestdata_ == NULL) initiatordigestdata_ = new ::mynigma::digestInfoPart;
  return initiatordigestdata_;
}
inline ::mynigma::digestInfoPart* digestInfoPair::release_initiatordigestdata() {
  clear_has_initiatordigestdata();
  ::mynigma::digestInfoPart* temp = initiatordigestdata_;
  initiatordigestdata_ = NULL;
  return temp;
}
inline void digestInfoPair::set_allocated_initiatordigestdata(::mynigma::digestInfoPart* initiatordigestdata) {
  delete initiatordigestdata_;
  initiatordigestdata_ = initiatordigestdata;
  if (initiatordigestdata) {
    set_has_initiatordigestdata();
  } else {
    clear_has_initiatordigestdata();
  }
}

// optional .mynigma.digestInfoPart responderDigestData = 2;
inline bool digestInfoPair::has_responderdigestdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void digestInfoPair::set_has_responderdigestdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void digestInfoPair::clear_has_responderdigestdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void digestInfoPair::clear_responderdigestdata() {
  if (responderdigestdata_ != NULL) responderdigestdata_->::mynigma::digestInfoPart::Clear();
  clear_has_responderdigestdata();
}
inline const ::mynigma::digestInfoPart& digestInfoPair::responderdigestdata() const {
  return responderdigestdata_ != NULL ? *responderdigestdata_ : *default_instance_->responderdigestdata_;
}
inline ::mynigma::digestInfoPart* digestInfoPair::mutable_responderdigestdata() {
  set_has_responderdigestdata();
  if (responderdigestdata_ == NULL) responderdigestdata_ = new ::mynigma::digestInfoPart;
  return responderdigestdata_;
}
inline ::mynigma::digestInfoPart* digestInfoPair::release_responderdigestdata() {
  clear_has_responderdigestdata();
  ::mynigma::digestInfoPart* temp = responderdigestdata_;
  responderdigestdata_ = NULL;
  return temp;
}
inline void digestInfoPair::set_allocated_responderdigestdata(::mynigma::digestInfoPart* responderdigestdata) {
  delete responderdigestdata_;
  responderdigestdata_ = responderdigestdata;
  if (responderdigestdata) {
    set_has_responderdigestdata();
  } else {
    clear_has_responderdigestdata();
  }
}

// -------------------------------------------------------------------

// digestInfoPart

// optional bytes publicVerKeyData = 1;
inline bool digestInfoPart::has_publicverkeydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void digestInfoPart::set_has_publicverkeydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void digestInfoPart::clear_has_publicverkeydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void digestInfoPart::clear_publicverkeydata() {
  if (publicverkeydata_ != &::google::protobuf::internal::kEmptyString) {
    publicverkeydata_->clear();
  }
  clear_has_publicverkeydata();
}
inline const ::std::string& digestInfoPart::publicverkeydata() const {
  return *publicverkeydata_;
}
inline void digestInfoPart::set_publicverkeydata(const ::std::string& value) {
  set_has_publicverkeydata();
  if (publicverkeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicverkeydata_ = new ::std::string;
  }
  publicverkeydata_->assign(value);
}
inline void digestInfoPart::set_publicverkeydata(const char* value) {
  set_has_publicverkeydata();
  if (publicverkeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicverkeydata_ = new ::std::string;
  }
  publicverkeydata_->assign(value);
}
inline void digestInfoPart::set_publicverkeydata(const void* value, size_t size) {
  set_has_publicverkeydata();
  if (publicverkeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicverkeydata_ = new ::std::string;
  }
  publicverkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* digestInfoPart::mutable_publicverkeydata() {
  set_has_publicverkeydata();
  if (publicverkeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicverkeydata_ = new ::std::string;
  }
  return publicverkeydata_;
}
inline ::std::string* digestInfoPart::release_publicverkeydata() {
  clear_has_publicverkeydata();
  if (publicverkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publicverkeydata_;
    publicverkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void digestInfoPart::set_allocated_publicverkeydata(::std::string* publicverkeydata) {
  if (publicverkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete publicverkeydata_;
  }
  if (publicverkeydata) {
    set_has_publicverkeydata();
    publicverkeydata_ = publicverkeydata;
  } else {
    clear_has_publicverkeydata();
    publicverkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes publicEncKeyData = 2;
inline bool digestInfoPart::has_publicenckeydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void digestInfoPart::set_has_publicenckeydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void digestInfoPart::clear_has_publicenckeydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void digestInfoPart::clear_publicenckeydata() {
  if (publicenckeydata_ != &::google::protobuf::internal::kEmptyString) {
    publicenckeydata_->clear();
  }
  clear_has_publicenckeydata();
}
inline const ::std::string& digestInfoPart::publicenckeydata() const {
  return *publicenckeydata_;
}
inline void digestInfoPart::set_publicenckeydata(const ::std::string& value) {
  set_has_publicenckeydata();
  if (publicenckeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicenckeydata_ = new ::std::string;
  }
  publicenckeydata_->assign(value);
}
inline void digestInfoPart::set_publicenckeydata(const char* value) {
  set_has_publicenckeydata();
  if (publicenckeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicenckeydata_ = new ::std::string;
  }
  publicenckeydata_->assign(value);
}
inline void digestInfoPart::set_publicenckeydata(const void* value, size_t size) {
  set_has_publicenckeydata();
  if (publicenckeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicenckeydata_ = new ::std::string;
  }
  publicenckeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* digestInfoPart::mutable_publicenckeydata() {
  set_has_publicenckeydata();
  if (publicenckeydata_ == &::google::protobuf::internal::kEmptyString) {
    publicenckeydata_ = new ::std::string;
  }
  return publicenckeydata_;
}
inline ::std::string* digestInfoPart::release_publicenckeydata() {
  clear_has_publicenckeydata();
  if (publicenckeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publicenckeydata_;
    publicenckeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void digestInfoPart::set_allocated_publicenckeydata(::std::string* publicenckeydata) {
  if (publicenckeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete publicenckeydata_;
  }
  if (publicenckeydata) {
    set_has_publicenckeydata();
    publicenckeydata_ = publicenckeydata;
  } else {
    clear_has_publicenckeydata();
    publicenckeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes secretData = 3;
inline bool digestInfoPart::has_secretdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void digestInfoPart::set_has_secretdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void digestInfoPart::clear_has_secretdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void digestInfoPart::clear_secretdata() {
  if (secretdata_ != &::google::protobuf::internal::kEmptyString) {
    secretdata_->clear();
  }
  clear_has_secretdata();
}
inline const ::std::string& digestInfoPart::secretdata() const {
  return *secretdata_;
}
inline void digestInfoPart::set_secretdata(const ::std::string& value) {
  set_has_secretdata();
  if (secretdata_ == &::google::protobuf::internal::kEmptyString) {
    secretdata_ = new ::std::string;
  }
  secretdata_->assign(value);
}
inline void digestInfoPart::set_secretdata(const char* value) {
  set_has_secretdata();
  if (secretdata_ == &::google::protobuf::internal::kEmptyString) {
    secretdata_ = new ::std::string;
  }
  secretdata_->assign(value);
}
inline void digestInfoPart::set_secretdata(const void* value, size_t size) {
  set_has_secretdata();
  if (secretdata_ == &::google::protobuf::internal::kEmptyString) {
    secretdata_ = new ::std::string;
  }
  secretdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* digestInfoPart::mutable_secretdata() {
  set_has_secretdata();
  if (secretdata_ == &::google::protobuf::internal::kEmptyString) {
    secretdata_ = new ::std::string;
  }
  return secretdata_;
}
inline ::std::string* digestInfoPart::release_secretdata() {
  clear_has_secretdata();
  if (secretdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretdata_;
    secretdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void digestInfoPart::set_allocated_secretdata(::std::string* secretdata) {
  if (secretdata_ != &::google::protobuf::internal::kEmptyString) {
    delete secretdata_;
  }
  if (secretdata) {
    set_has_secretdata();
    secretdata_ = secretdata;
  } else {
    clear_has_secretdata();
    secretdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceUUID = 4;
inline bool digestInfoPart::has_deviceuuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void digestInfoPart::set_has_deviceuuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void digestInfoPart::clear_has_deviceuuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void digestInfoPart::clear_deviceuuid() {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    deviceuuid_->clear();
  }
  clear_has_deviceuuid();
}
inline const ::std::string& digestInfoPart::deviceuuid() const {
  return *deviceuuid_;
}
inline void digestInfoPart::set_deviceuuid(const ::std::string& value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void digestInfoPart::set_deviceuuid(const char* value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void digestInfoPart::set_deviceuuid(const char* value, size_t size) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* digestInfoPart::mutable_deviceuuid() {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  return deviceuuid_;
}
inline ::std::string* digestInfoPart::release_deviceuuid() {
  clear_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceuuid_;
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void digestInfoPart::set_allocated_deviceuuid(::std::string* deviceuuid) {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceuuid_;
  }
  if (deviceuuid) {
    set_has_deviceuuid();
    deviceuuid_ = deviceuuid;
  } else {
    clear_has_deviceuuid();
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceKeyLabel = 5;
inline bool digestInfoPart::has_devicekeylabel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void digestInfoPart::set_has_devicekeylabel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void digestInfoPart::clear_has_devicekeylabel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void digestInfoPart::clear_devicekeylabel() {
  if (devicekeylabel_ != &::google::protobuf::internal::kEmptyString) {
    devicekeylabel_->clear();
  }
  clear_has_devicekeylabel();
}
inline const ::std::string& digestInfoPart::devicekeylabel() const {
  return *devicekeylabel_;
}
inline void digestInfoPart::set_devicekeylabel(const ::std::string& value) {
  set_has_devicekeylabel();
  if (devicekeylabel_ == &::google::protobuf::internal::kEmptyString) {
    devicekeylabel_ = new ::std::string;
  }
  devicekeylabel_->assign(value);
}
inline void digestInfoPart::set_devicekeylabel(const char* value) {
  set_has_devicekeylabel();
  if (devicekeylabel_ == &::google::protobuf::internal::kEmptyString) {
    devicekeylabel_ = new ::std::string;
  }
  devicekeylabel_->assign(value);
}
inline void digestInfoPart::set_devicekeylabel(const char* value, size_t size) {
  set_has_devicekeylabel();
  if (devicekeylabel_ == &::google::protobuf::internal::kEmptyString) {
    devicekeylabel_ = new ::std::string;
  }
  devicekeylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* digestInfoPart::mutable_devicekeylabel() {
  set_has_devicekeylabel();
  if (devicekeylabel_ == &::google::protobuf::internal::kEmptyString) {
    devicekeylabel_ = new ::std::string;
  }
  return devicekeylabel_;
}
inline ::std::string* digestInfoPart::release_devicekeylabel() {
  clear_has_devicekeylabel();
  if (devicekeylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicekeylabel_;
    devicekeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void digestInfoPart::set_allocated_devicekeylabel(::std::string* devicekeylabel) {
  if (devicekeylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete devicekeylabel_;
  }
  if (devicekeylabel) {
    set_has_devicekeylabel();
    devicekeylabel_ = devicekeylabel;
  } else {
    clear_has_devicekeylabel();
    devicekeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mynigma

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_deviceMessages_2eproto__INCLUDED
