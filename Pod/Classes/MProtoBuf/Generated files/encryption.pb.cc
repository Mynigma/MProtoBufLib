// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encryption.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "encryption.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mynigma {

namespace {

const ::google::protobuf::Descriptor* keyIntroduction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  keyIntroduction_reflection_ = NULL;
const ::google::protobuf::Descriptor* encrSessionKeyEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  encrSessionKeyEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* versionData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  versionData_reflection_ = NULL;
const ::google::protobuf::Descriptor* HMACData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HMACData_reflection_ = NULL;
const ::google::protobuf::Descriptor* encryptedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  encryptedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* simpleEncryptedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  simpleEncryptedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* signedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  signedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* payloadPart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  payloadPart_reflection_ = NULL;
const ::google::protobuf::Descriptor* payloadPart_emailRecipient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  payloadPart_emailRecipient_reflection_ = NULL;
const ::google::protobuf::Descriptor* payloadPart_fileAttachment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  payloadPart_fileAttachment_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* payloadPart_addresseeType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_encryption_2eproto() {
  protobuf_AddDesc_encryption_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "encryption.proto");
  GOOGLE_CHECK(file != NULL);
  keyIntroduction_descriptor_ = file->message_type(0);
  static const int keyIntroduction_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, oldkeylabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, newkeylabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, newenckey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, newverkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, datesigned_),
  };
  keyIntroduction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      keyIntroduction_descriptor_,
      keyIntroduction::default_instance_,
      keyIntroduction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(keyIntroduction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(keyIntroduction));
  encrSessionKeyEntry_descriptor_ = file->message_type(1);
  static const int encrSessionKeyEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, keylabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, encrsessionkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, introductiondata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, emailaddress_),
  };
  encrSessionKeyEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      encrSessionKeyEntry_descriptor_,
      encrSessionKeyEntry::default_instance_,
      encrSessionKeyEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encrSessionKeyEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(encrSessionKeyEntry));
  versionData_descriptor_ = file->message_type(2);
  static const int versionData_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(versionData, version_),
  };
  versionData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      versionData_descriptor_,
      versionData::default_instance_,
      versionData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(versionData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(versionData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(versionData));
  HMACData_descriptor_ = file->message_type(3);
  static const int HMACData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMACData, encrypteddata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMACData, hmac_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMACData, version_),
  };
  HMACData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HMACData_descriptor_,
      HMACData::default_instance_,
      HMACData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMACData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMACData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HMACData));
  encryptedData_descriptor_ = file->message_type(4);
  static const int encryptedData_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, encrmessagedata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, encrsessionkeytable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, encrattachmentdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, attachmentshmac_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, messagehmac_),
  };
  encryptedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      encryptedData_descriptor_,
      encryptedData::default_instance_,
      encryptedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(encryptedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(encryptedData));
  simpleEncryptedData_descriptor_ = file->message_type(5);
  static const int simpleEncryptedData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, encrypteddata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, encryptedsessionkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, keylabel_),
  };
  simpleEncryptedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      simpleEncryptedData_descriptor_,
      simpleEncryptedData::default_instance_,
      simpleEncryptedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(simpleEncryptedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(simpleEncryptedData));
  signedData_descriptor_ = file->message_type(6);
  static const int signedData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, keylabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, version_),
  };
  signedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      signedData_descriptor_,
      signedData::default_instance_,
      signedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(signedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(signedData));
  payloadPart_descriptor_ = file->message_type(7);
  static const int payloadPart_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, body_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, htmlbody_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, subject_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, datesent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, declaration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, recipients_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, attachments_),
  };
  payloadPart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      payloadPart_descriptor_,
      payloadPart::default_instance_,
      payloadPart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(payloadPart));
  payloadPart_emailRecipient_descriptor_ = payloadPart_descriptor_->nested_type(0);
  static const int payloadPart_emailRecipient_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_emailRecipient, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_emailRecipient, email_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_emailRecipient, type_),
  };
  payloadPart_emailRecipient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      payloadPart_emailRecipient_descriptor_,
      payloadPart_emailRecipient::default_instance_,
      payloadPart_emailRecipient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_emailRecipient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_emailRecipient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(payloadPart_emailRecipient));
  payloadPart_fileAttachment_descriptor_ = payloadPart_descriptor_->nested_type(1);
  static const int payloadPart_fileAttachment_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, contentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, hashedvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, partid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, remoteurl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, isinline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, contenttype_),
  };
  payloadPart_fileAttachment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      payloadPart_fileAttachment_descriptor_,
      payloadPart_fileAttachment::default_instance_,
      payloadPart_fileAttachment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(payloadPart_fileAttachment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(payloadPart_fileAttachment));
  payloadPart_addresseeType_descriptor_ = payloadPart_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_encryption_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    keyIntroduction_descriptor_, &keyIntroduction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    encrSessionKeyEntry_descriptor_, &encrSessionKeyEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    versionData_descriptor_, &versionData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HMACData_descriptor_, &HMACData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    encryptedData_descriptor_, &encryptedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    simpleEncryptedData_descriptor_, &simpleEncryptedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    signedData_descriptor_, &signedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    payloadPart_descriptor_, &payloadPart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    payloadPart_emailRecipient_descriptor_, &payloadPart_emailRecipient::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    payloadPart_fileAttachment_descriptor_, &payloadPart_fileAttachment::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_encryption_2eproto() {
  delete keyIntroduction::default_instance_;
  delete keyIntroduction_reflection_;
  delete encrSessionKeyEntry::default_instance_;
  delete encrSessionKeyEntry_reflection_;
  delete versionData::default_instance_;
  delete versionData_reflection_;
  delete HMACData::default_instance_;
  delete HMACData_reflection_;
  delete encryptedData::default_instance_;
  delete encryptedData_reflection_;
  delete simpleEncryptedData::default_instance_;
  delete simpleEncryptedData_reflection_;
  delete signedData::default_instance_;
  delete signedData_reflection_;
  delete payloadPart::default_instance_;
  delete payloadPart_reflection_;
  delete payloadPart_emailRecipient::default_instance_;
  delete payloadPart_emailRecipient_reflection_;
  delete payloadPart_fileAttachment::default_instance_;
  delete payloadPart_fileAttachment_reflection_;
}

void protobuf_AddDesc_encryption_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020encryption.proto\022\007mynigma\"\231\001\n\017keyIntro"
    "duction\022\023\n\013oldKeyLabel\030\001 \001(\t\022\023\n\013newKeyLa"
    "bel\030\002 \001(\t\022\021\n\tnewEncKey\030\003 \001(\014\022\021\n\tnewVerKe"
    "y\030\004 \001(\014\022\021\n\tsignature\030\005 \001(\014\022\017\n\007version\030\006 "
    "\001(\t\022\022\n\ndateSigned\030\007 \001(\005\"o\n\023encrSessionKe"
    "yEntry\022\020\n\010keyLabel\030\001 \002(\t\022\026\n\016encrSessionK"
    "ey\030\002 \002(\014\022\030\n\020introductionData\030\003 \001(\014\022\024\n\014em"
    "ailAddress\030\004 \001(\t\"\036\n\013versionData\022\017\n\007versi"
    "on\030\003 \001(\t\"@\n\010HMACData\022\025\n\rencryptedData\030\001 "
    "\001(\014\022\014\n\004HMAC\030\002 \001(\014\022\017\n\007version\030\003 \001(\t\"\314\001\n\re"
    "ncryptedData\022\027\n\017encrMessageData\030\001 \001(\014\0229\n"
    "\023encrSessionKeyTable\030\002 \003(\0132\034.mynigma.enc"
    "rSessionKeyEntry\022\017\n\007version\030\003 \001(\t\022\014\n\004inf"
    "o\030\004 \001(\t\022\032\n\022encrAttachmentData\030\005 \003(\014\022\027\n\017a"
    "ttachmentsHMAC\030\006 \003(\014\022\023\n\013messageHMAC\030\007 \001("
    "\014\"l\n\023simpleEncryptedData\022\025\n\rencryptedDat"
    "a\030\001 \001(\014\022\033\n\023encryptedSessionKey\030\002 \001(\014\022\017\n\007"
    "version\030\003 \001(\t\022\020\n\010keyLabel\030\004 \001(\t\"P\n\nsigne"
    "dData\022\020\n\010keyLabel\030\001 \001(\t\022\021\n\tsignature\030\002 \001"
    "(\014\022\014\n\004data\030\003 \001(\014\022\017\n\007version\030\004 \001(\t\"\267\004\n\013pa"
    "yloadPart\022\014\n\004body\030\001 \001(\t\022\020\n\010htmlBody\030\002 \001("
    "\t\022\017\n\007subject\030\003 \001(\t\022\020\n\010dateSent\030\004 \001(\005\022\023\n\013"
    "declaration\030\007 \001(\014\0227\n\nrecipients\030\005 \003(\0132#."
    "mynigma.payloadPart.emailRecipient\0228\n\013at"
    "tachments\030\006 \003(\0132#.mynigma.payloadPart.fi"
    "leAttachment\032e\n\016emailRecipient\022\014\n\004name\030\001"
    " \001(\t\022\r\n\005email\030\002 \001(\t\0226\n\004type\030\003 \001(\0162\".myni"
    "gma.payloadPart.addresseeType:\004T_TO\032\251\001\n\016"
    "fileAttachment\022\020\n\010filename\030\001 \001(\t\022\021\n\tcont"
    "entID\030\002 \001(\t\022\014\n\004size\030\003 \001(\005\022\023\n\013hashedValue"
    "\030\004 \001(\014\022\016\n\006partID\030\005 \001(\t\022\021\n\tremoteURL\030\006 \001("
    "\t\022\027\n\010isInline\030\007 \001(\010:\005false\022\023\n\013contentTyp"
    "e\030\010 \001(\t\"J\n\raddresseeType\022\n\n\006T_FROM\020\000\022\016\n\n"
    "T_REPLY_TO\020\001\022\010\n\004T_TO\020\002\022\010\n\004T_CC\020\003\022\t\n\005T_BC"
    "C\020\004B$\n\026org.mynigma.protoc.genB\nEncryptio"
    "n", 1401);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "encryption.proto", &protobuf_RegisterTypes);
  keyIntroduction::default_instance_ = new keyIntroduction();
  encrSessionKeyEntry::default_instance_ = new encrSessionKeyEntry();
  versionData::default_instance_ = new versionData();
  HMACData::default_instance_ = new HMACData();
  encryptedData::default_instance_ = new encryptedData();
  simpleEncryptedData::default_instance_ = new simpleEncryptedData();
  signedData::default_instance_ = new signedData();
  payloadPart::default_instance_ = new payloadPart();
  payloadPart_emailRecipient::default_instance_ = new payloadPart_emailRecipient();
  payloadPart_fileAttachment::default_instance_ = new payloadPart_fileAttachment();
  keyIntroduction::default_instance_->InitAsDefaultInstance();
  encrSessionKeyEntry::default_instance_->InitAsDefaultInstance();
  versionData::default_instance_->InitAsDefaultInstance();
  HMACData::default_instance_->InitAsDefaultInstance();
  encryptedData::default_instance_->InitAsDefaultInstance();
  simpleEncryptedData::default_instance_->InitAsDefaultInstance();
  signedData::default_instance_->InitAsDefaultInstance();
  payloadPart::default_instance_->InitAsDefaultInstance();
  payloadPart_emailRecipient::default_instance_->InitAsDefaultInstance();
  payloadPart_fileAttachment::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_encryption_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_encryption_2eproto {
  StaticDescriptorInitializer_encryption_2eproto() {
    protobuf_AddDesc_encryption_2eproto();
  }
} static_descriptor_initializer_encryption_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int keyIntroduction::kOldKeyLabelFieldNumber;
const int keyIntroduction::kNewKeyLabelFieldNumber;
const int keyIntroduction::kNewEncKeyFieldNumber;
const int keyIntroduction::kNewVerKeyFieldNumber;
const int keyIntroduction::kSignatureFieldNumber;
const int keyIntroduction::kVersionFieldNumber;
const int keyIntroduction::kDateSignedFieldNumber;
#endif  // !_MSC_VER

keyIntroduction::keyIntroduction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void keyIntroduction::InitAsDefaultInstance() {
}

keyIntroduction::keyIntroduction(const keyIntroduction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void keyIntroduction::SharedCtor() {
  _cached_size_ = 0;
  oldkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  newkeylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  newenckey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  newverkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  datesigned_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

keyIntroduction::~keyIntroduction() {
  SharedDtor();
}

void keyIntroduction::SharedDtor() {
  if (oldkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete oldkeylabel_;
  }
  if (newkeylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete newkeylabel_;
  }
  if (newenckey_ != &::google::protobuf::internal::kEmptyString) {
    delete newenckey_;
  }
  if (newverkey_ != &::google::protobuf::internal::kEmptyString) {
    delete newverkey_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void keyIntroduction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* keyIntroduction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return keyIntroduction_descriptor_;
}

const keyIntroduction& keyIntroduction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

keyIntroduction* keyIntroduction::default_instance_ = NULL;

keyIntroduction* keyIntroduction::New() const {
  return new keyIntroduction;
}

void keyIntroduction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_oldkeylabel()) {
      if (oldkeylabel_ != &::google::protobuf::internal::kEmptyString) {
        oldkeylabel_->clear();
      }
    }
    if (has_newkeylabel()) {
      if (newkeylabel_ != &::google::protobuf::internal::kEmptyString) {
        newkeylabel_->clear();
      }
    }
    if (has_newenckey()) {
      if (newenckey_ != &::google::protobuf::internal::kEmptyString) {
        newenckey_->clear();
      }
    }
    if (has_newverkey()) {
      if (newverkey_ != &::google::protobuf::internal::kEmptyString) {
        newverkey_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    datesigned_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool keyIntroduction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string oldKeyLabel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_oldkeylabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->oldkeylabel().data(), this->oldkeylabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_newKeyLabel;
        break;
      }

      // optional string newKeyLabel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newKeyLabel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_newkeylabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->newkeylabel().data(), this->newkeylabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_newEncKey;
        break;
      }

      // optional bytes newEncKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newEncKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_newenckey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_newVerKey;
        break;
      }

      // optional bytes newVerKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newVerKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_newverkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_signature;
        break;
      }

      // optional bytes signature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_dateSigned;
        break;
      }

      // optional int32 dateSigned = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dateSigned:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datesigned_)));
          set_has_datesigned();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void keyIntroduction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string oldKeyLabel = 1;
  if (has_oldkeylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->oldkeylabel().data(), this->oldkeylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->oldkeylabel(), output);
  }

  // optional string newKeyLabel = 2;
  if (has_newkeylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->newkeylabel().data(), this->newkeylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->newkeylabel(), output);
  }

  // optional bytes newEncKey = 3;
  if (has_newenckey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->newenckey(), output);
  }

  // optional bytes newVerKey = 4;
  if (has_newverkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->newverkey(), output);
  }

  // optional bytes signature = 5;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->signature(), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->version(), output);
  }

  // optional int32 dateSigned = 7;
  if (has_datesigned()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->datesigned(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* keyIntroduction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string oldKeyLabel = 1;
  if (has_oldkeylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->oldkeylabel().data(), this->oldkeylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->oldkeylabel(), target);
  }

  // optional string newKeyLabel = 2;
  if (has_newkeylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->newkeylabel().data(), this->newkeylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->newkeylabel(), target);
  }

  // optional bytes newEncKey = 3;
  if (has_newenckey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->newenckey(), target);
  }

  // optional bytes newVerKey = 4;
  if (has_newverkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->newverkey(), target);
  }

  // optional bytes signature = 5;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->signature(), target);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  // optional int32 dateSigned = 7;
  if (has_datesigned()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->datesigned(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int keyIntroduction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string oldKeyLabel = 1;
    if (has_oldkeylabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->oldkeylabel());
    }

    // optional string newKeyLabel = 2;
    if (has_newkeylabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->newkeylabel());
    }

    // optional bytes newEncKey = 3;
    if (has_newenckey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->newenckey());
    }

    // optional bytes newVerKey = 4;
    if (has_newverkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->newverkey());
    }

    // optional bytes signature = 5;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional int32 dateSigned = 7;
    if (has_datesigned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datesigned());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void keyIntroduction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const keyIntroduction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const keyIntroduction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void keyIntroduction::MergeFrom(const keyIntroduction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oldkeylabel()) {
      set_oldkeylabel(from.oldkeylabel());
    }
    if (from.has_newkeylabel()) {
      set_newkeylabel(from.newkeylabel());
    }
    if (from.has_newenckey()) {
      set_newenckey(from.newenckey());
    }
    if (from.has_newverkey()) {
      set_newverkey(from.newverkey());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_datesigned()) {
      set_datesigned(from.datesigned());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void keyIntroduction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void keyIntroduction::CopyFrom(const keyIntroduction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool keyIntroduction::IsInitialized() const {

  return true;
}

void keyIntroduction::Swap(keyIntroduction* other) {
  if (other != this) {
    std::swap(oldkeylabel_, other->oldkeylabel_);
    std::swap(newkeylabel_, other->newkeylabel_);
    std::swap(newenckey_, other->newenckey_);
    std::swap(newverkey_, other->newverkey_);
    std::swap(signature_, other->signature_);
    std::swap(version_, other->version_);
    std::swap(datesigned_, other->datesigned_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata keyIntroduction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = keyIntroduction_descriptor_;
  metadata.reflection = keyIntroduction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int encrSessionKeyEntry::kKeyLabelFieldNumber;
const int encrSessionKeyEntry::kEncrSessionKeyFieldNumber;
const int encrSessionKeyEntry::kIntroductionDataFieldNumber;
const int encrSessionKeyEntry::kEmailAddressFieldNumber;
#endif  // !_MSC_VER

encrSessionKeyEntry::encrSessionKeyEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void encrSessionKeyEntry::InitAsDefaultInstance() {
}

encrSessionKeyEntry::encrSessionKeyEntry(const encrSessionKeyEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void encrSessionKeyEntry::SharedCtor() {
  _cached_size_ = 0;
  keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  introductiondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  emailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

encrSessionKeyEntry::~encrSessionKeyEntry() {
  SharedDtor();
}

void encrSessionKeyEntry::SharedDtor() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (encrsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encrsessionkey_;
  }
  if (introductiondata_ != &::google::protobuf::internal::kEmptyString) {
    delete introductiondata_;
  }
  if (emailaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete emailaddress_;
  }
  if (this != default_instance_) {
  }
}

void encrSessionKeyEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* encrSessionKeyEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return encrSessionKeyEntry_descriptor_;
}

const encrSessionKeyEntry& encrSessionKeyEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

encrSessionKeyEntry* encrSessionKeyEntry::default_instance_ = NULL;

encrSessionKeyEntry* encrSessionKeyEntry::New() const {
  return new encrSessionKeyEntry;
}

void encrSessionKeyEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_keylabel()) {
      if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
        keylabel_->clear();
      }
    }
    if (has_encrsessionkey()) {
      if (encrsessionkey_ != &::google::protobuf::internal::kEmptyString) {
        encrsessionkey_->clear();
      }
    }
    if (has_introductiondata()) {
      if (introductiondata_ != &::google::protobuf::internal::kEmptyString) {
        introductiondata_->clear();
      }
    }
    if (has_emailaddress()) {
      if (emailaddress_ != &::google::protobuf::internal::kEmptyString) {
        emailaddress_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool encrSessionKeyEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string keyLabel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keylabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->keylabel().data(), this->keylabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrSessionKey;
        break;
      }

      // required bytes encrSessionKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrSessionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrsessionkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_introductionData;
        break;
      }

      // optional bytes introductionData = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_introductionData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_introductiondata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_emailAddress;
        break;
      }

      // optional string emailAddress = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_emailAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_emailaddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->emailaddress().data(), this->emailaddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void encrSessionKeyEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string keyLabel = 1;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->keylabel(), output);
  }

  // required bytes encrSessionKey = 2;
  if (has_encrsessionkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encrsessionkey(), output);
  }

  // optional bytes introductionData = 3;
  if (has_introductiondata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->introductiondata(), output);
  }

  // optional string emailAddress = 4;
  if (has_emailaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->emailaddress().data(), this->emailaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->emailaddress(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* encrSessionKeyEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string keyLabel = 1;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->keylabel(), target);
  }

  // required bytes encrSessionKey = 2;
  if (has_encrsessionkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encrsessionkey(), target);
  }

  // optional bytes introductionData = 3;
  if (has_introductiondata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->introductiondata(), target);
  }

  // optional string emailAddress = 4;
  if (has_emailaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->emailaddress().data(), this->emailaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->emailaddress(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int encrSessionKeyEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string keyLabel = 1;
    if (has_keylabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->keylabel());
    }

    // required bytes encrSessionKey = 2;
    if (has_encrsessionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrsessionkey());
    }

    // optional bytes introductionData = 3;
    if (has_introductiondata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->introductiondata());
    }

    // optional string emailAddress = 4;
    if (has_emailaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->emailaddress());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void encrSessionKeyEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const encrSessionKeyEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const encrSessionKeyEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void encrSessionKeyEntry::MergeFrom(const encrSessionKeyEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keylabel()) {
      set_keylabel(from.keylabel());
    }
    if (from.has_encrsessionkey()) {
      set_encrsessionkey(from.encrsessionkey());
    }
    if (from.has_introductiondata()) {
      set_introductiondata(from.introductiondata());
    }
    if (from.has_emailaddress()) {
      set_emailaddress(from.emailaddress());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void encrSessionKeyEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void encrSessionKeyEntry::CopyFrom(const encrSessionKeyEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool encrSessionKeyEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void encrSessionKeyEntry::Swap(encrSessionKeyEntry* other) {
  if (other != this) {
    std::swap(keylabel_, other->keylabel_);
    std::swap(encrsessionkey_, other->encrsessionkey_);
    std::swap(introductiondata_, other->introductiondata_);
    std::swap(emailaddress_, other->emailaddress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata encrSessionKeyEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = encrSessionKeyEntry_descriptor_;
  metadata.reflection = encrSessionKeyEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int versionData::kVersionFieldNumber;
#endif  // !_MSC_VER

versionData::versionData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void versionData::InitAsDefaultInstance() {
}

versionData::versionData(const versionData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void versionData::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

versionData::~versionData() {
  SharedDtor();
}

void versionData::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void versionData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* versionData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return versionData_descriptor_;
}

const versionData& versionData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

versionData* versionData::default_instance_ = NULL;

versionData* versionData::New() const {
  return new versionData;
}

void versionData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool versionData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void versionData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* versionData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int versionData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void versionData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const versionData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const versionData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void versionData::MergeFrom(const versionData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void versionData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void versionData::CopyFrom(const versionData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool versionData::IsInitialized() const {

  return true;
}

void versionData::Swap(versionData* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata versionData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = versionData_descriptor_;
  metadata.reflection = versionData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HMACData::kEncryptedDataFieldNumber;
const int HMACData::kHMACFieldNumber;
const int HMACData::kVersionFieldNumber;
#endif  // !_MSC_VER

HMACData::HMACData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HMACData::InitAsDefaultInstance() {
}

HMACData::HMACData(const HMACData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HMACData::SharedCtor() {
  _cached_size_ = 0;
  encrypteddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HMACData::~HMACData() {
  SharedDtor();
}

void HMACData::SharedDtor() {
  if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypteddata_;
  }
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void HMACData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HMACData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HMACData_descriptor_;
}

const HMACData& HMACData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

HMACData* HMACData::default_instance_ = NULL;

HMACData* HMACData::New() const {
  return new HMACData;
}

void HMACData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_encrypteddata()) {
      if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
        encrypteddata_->clear();
      }
    }
    if (has_hmac()) {
      if (hmac_ != &::google::protobuf::internal::kEmptyString) {
        hmac_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HMACData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes encryptedData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypteddata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_HMAC;
        break;
      }

      // optional bytes HMAC = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_HMAC:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hmac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HMACData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes encryptedData = 1;
  if (has_encrypteddata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->encrypteddata(), output);
  }

  // optional bytes HMAC = 2;
  if (has_hmac()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->hmac(), output);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HMACData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes encryptedData = 1;
  if (has_encrypteddata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->encrypteddata(), target);
  }

  // optional bytes HMAC = 2;
  if (has_hmac()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hmac(), target);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HMACData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes encryptedData = 1;
    if (has_encrypteddata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypteddata());
    }

    // optional bytes HMAC = 2;
    if (has_hmac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hmac());
    }

    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HMACData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HMACData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HMACData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HMACData::MergeFrom(const HMACData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encrypteddata()) {
      set_encrypteddata(from.encrypteddata());
    }
    if (from.has_hmac()) {
      set_hmac(from.hmac());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HMACData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HMACData::CopyFrom(const HMACData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HMACData::IsInitialized() const {

  return true;
}

void HMACData::Swap(HMACData* other) {
  if (other != this) {
    std::swap(encrypteddata_, other->encrypteddata_);
    std::swap(hmac_, other->hmac_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HMACData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HMACData_descriptor_;
  metadata.reflection = HMACData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int encryptedData::kEncrMessageDataFieldNumber;
const int encryptedData::kEncrSessionKeyTableFieldNumber;
const int encryptedData::kVersionFieldNumber;
const int encryptedData::kInfoFieldNumber;
const int encryptedData::kEncrAttachmentDataFieldNumber;
const int encryptedData::kAttachmentsHMACFieldNumber;
const int encryptedData::kMessageHMACFieldNumber;
#endif  // !_MSC_VER

encryptedData::encryptedData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void encryptedData::InitAsDefaultInstance() {
}

encryptedData::encryptedData(const encryptedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void encryptedData::SharedCtor() {
  _cached_size_ = 0;
  encrmessagedata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  messagehmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

encryptedData::~encryptedData() {
  SharedDtor();
}

void encryptedData::SharedDtor() {
  if (encrmessagedata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrmessagedata_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (messagehmac_ != &::google::protobuf::internal::kEmptyString) {
    delete messagehmac_;
  }
  if (this != default_instance_) {
  }
}

void encryptedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* encryptedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return encryptedData_descriptor_;
}

const encryptedData& encryptedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

encryptedData* encryptedData::default_instance_ = NULL;

encryptedData* encryptedData::New() const {
  return new encryptedData;
}

void encryptedData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_encrmessagedata()) {
      if (encrmessagedata_ != &::google::protobuf::internal::kEmptyString) {
        encrmessagedata_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_info()) {
      if (info_ != &::google::protobuf::internal::kEmptyString) {
        info_->clear();
      }
    }
    if (has_messagehmac()) {
      if (messagehmac_ != &::google::protobuf::internal::kEmptyString) {
        messagehmac_->clear();
      }
    }
  }
  encrsessionkeytable_.Clear();
  encrattachmentdata_.Clear();
  attachmentshmac_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool encryptedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes encrMessageData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrmessagedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrSessionKeyTable;
        break;
      }

      // repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrSessionKeyTable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_encrsessionkeytable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrSessionKeyTable;
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_info;
        break;
      }

      // optional string info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_info()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->info().data(), this->info().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_encrAttachmentData;
        break;
      }

      // repeated bytes encrAttachmentData = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrAttachmentData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_encrattachmentdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_encrAttachmentData;
        if (input->ExpectTag(50)) goto parse_attachmentsHMAC;
        break;
      }

      // repeated bytes attachmentsHMAC = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attachmentsHMAC:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_attachmentshmac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_attachmentsHMAC;
        if (input->ExpectTag(58)) goto parse_messageHMAC;
        break;
      }

      // optional bytes messageHMAC = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_messageHMAC:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_messagehmac()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void encryptedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes encrMessageData = 1;
  if (has_encrmessagedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->encrmessagedata(), output);
  }

  // repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
  for (int i = 0; i < this->encrsessionkeytable_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->encrsessionkeytable(i), output);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }

  // optional string info = 4;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->info(), output);
  }

  // repeated bytes encrAttachmentData = 5;
  for (int i = 0; i < this->encrattachmentdata_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->encrattachmentdata(i), output);
  }

  // repeated bytes attachmentsHMAC = 6;
  for (int i = 0; i < this->attachmentshmac_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->attachmentshmac(i), output);
  }

  // optional bytes messageHMAC = 7;
  if (has_messagehmac()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->messagehmac(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* encryptedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes encrMessageData = 1;
  if (has_encrmessagedata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->encrmessagedata(), target);
  }

  // repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
  for (int i = 0; i < this->encrsessionkeytable_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->encrsessionkeytable(i), target);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  // optional string info = 4;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->info(), target);
  }

  // repeated bytes encrAttachmentData = 5;
  for (int i = 0; i < this->encrattachmentdata_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(5, this->encrattachmentdata(i), target);
  }

  // repeated bytes attachmentsHMAC = 6;
  for (int i = 0; i < this->attachmentshmac_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(6, this->attachmentshmac(i), target);
  }

  // optional bytes messageHMAC = 7;
  if (has_messagehmac()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->messagehmac(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int encryptedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes encrMessageData = 1;
    if (has_encrmessagedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrmessagedata());
    }

    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string info = 4;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->info());
    }

    // optional bytes messageHMAC = 7;
    if (has_messagehmac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->messagehmac());
    }

  }
  // repeated .mynigma.encrSessionKeyEntry encrSessionKeyTable = 2;
  total_size += 1 * this->encrsessionkeytable_size();
  for (int i = 0; i < this->encrsessionkeytable_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->encrsessionkeytable(i));
  }

  // repeated bytes encrAttachmentData = 5;
  total_size += 1 * this->encrattachmentdata_size();
  for (int i = 0; i < this->encrattachmentdata_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->encrattachmentdata(i));
  }

  // repeated bytes attachmentsHMAC = 6;
  total_size += 1 * this->attachmentshmac_size();
  for (int i = 0; i < this->attachmentshmac_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->attachmentshmac(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void encryptedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const encryptedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const encryptedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void encryptedData::MergeFrom(const encryptedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  encrsessionkeytable_.MergeFrom(from.encrsessionkeytable_);
  encrattachmentdata_.MergeFrom(from.encrattachmentdata_);
  attachmentshmac_.MergeFrom(from.attachmentshmac_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encrmessagedata()) {
      set_encrmessagedata(from.encrmessagedata());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
    if (from.has_messagehmac()) {
      set_messagehmac(from.messagehmac());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void encryptedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void encryptedData::CopyFrom(const encryptedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool encryptedData::IsInitialized() const {

  for (int i = 0; i < encrsessionkeytable_size(); i++) {
    if (!this->encrsessionkeytable(i).IsInitialized()) return false;
  }
  return true;
}

void encryptedData::Swap(encryptedData* other) {
  if (other != this) {
    std::swap(encrmessagedata_, other->encrmessagedata_);
    encrsessionkeytable_.Swap(&other->encrsessionkeytable_);
    std::swap(version_, other->version_);
    std::swap(info_, other->info_);
    encrattachmentdata_.Swap(&other->encrattachmentdata_);
    attachmentshmac_.Swap(&other->attachmentshmac_);
    std::swap(messagehmac_, other->messagehmac_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata encryptedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = encryptedData_descriptor_;
  metadata.reflection = encryptedData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int simpleEncryptedData::kEncryptedDataFieldNumber;
const int simpleEncryptedData::kEncryptedSessionKeyFieldNumber;
const int simpleEncryptedData::kVersionFieldNumber;
const int simpleEncryptedData::kKeyLabelFieldNumber;
#endif  // !_MSC_VER

simpleEncryptedData::simpleEncryptedData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void simpleEncryptedData::InitAsDefaultInstance() {
}

simpleEncryptedData::simpleEncryptedData(const simpleEncryptedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void simpleEncryptedData::SharedCtor() {
  _cached_size_ = 0;
  encrypteddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encryptedsessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

simpleEncryptedData::~simpleEncryptedData() {
  SharedDtor();
}

void simpleEncryptedData::SharedDtor() {
  if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypteddata_;
  }
  if (encryptedsessionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptedsessionkey_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (this != default_instance_) {
  }
}

void simpleEncryptedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* simpleEncryptedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return simpleEncryptedData_descriptor_;
}

const simpleEncryptedData& simpleEncryptedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

simpleEncryptedData* simpleEncryptedData::default_instance_ = NULL;

simpleEncryptedData* simpleEncryptedData::New() const {
  return new simpleEncryptedData;
}

void simpleEncryptedData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_encrypteddata()) {
      if (encrypteddata_ != &::google::protobuf::internal::kEmptyString) {
        encrypteddata_->clear();
      }
    }
    if (has_encryptedsessionkey()) {
      if (encryptedsessionkey_ != &::google::protobuf::internal::kEmptyString) {
        encryptedsessionkey_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_keylabel()) {
      if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
        keylabel_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool simpleEncryptedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes encryptedData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypteddata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encryptedSessionKey;
        break;
      }

      // optional bytes encryptedSessionKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encryptedSessionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encryptedsessionkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_keyLabel;
        break;
      }

      // optional string keyLabel = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyLabel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keylabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->keylabel().data(), this->keylabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void simpleEncryptedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes encryptedData = 1;
  if (has_encrypteddata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->encrypteddata(), output);
  }

  // optional bytes encryptedSessionKey = 2;
  if (has_encryptedsessionkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encryptedsessionkey(), output);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }

  // optional string keyLabel = 4;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->keylabel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* simpleEncryptedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes encryptedData = 1;
  if (has_encrypteddata()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->encrypteddata(), target);
  }

  // optional bytes encryptedSessionKey = 2;
  if (has_encryptedsessionkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encryptedsessionkey(), target);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  // optional string keyLabel = 4;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->keylabel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int simpleEncryptedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes encryptedData = 1;
    if (has_encrypteddata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypteddata());
    }

    // optional bytes encryptedSessionKey = 2;
    if (has_encryptedsessionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encryptedsessionkey());
    }

    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string keyLabel = 4;
    if (has_keylabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->keylabel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void simpleEncryptedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const simpleEncryptedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const simpleEncryptedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void simpleEncryptedData::MergeFrom(const simpleEncryptedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_encrypteddata()) {
      set_encrypteddata(from.encrypteddata());
    }
    if (from.has_encryptedsessionkey()) {
      set_encryptedsessionkey(from.encryptedsessionkey());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_keylabel()) {
      set_keylabel(from.keylabel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void simpleEncryptedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void simpleEncryptedData::CopyFrom(const simpleEncryptedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool simpleEncryptedData::IsInitialized() const {

  return true;
}

void simpleEncryptedData::Swap(simpleEncryptedData* other) {
  if (other != this) {
    std::swap(encrypteddata_, other->encrypteddata_);
    std::swap(encryptedsessionkey_, other->encryptedsessionkey_);
    std::swap(version_, other->version_);
    std::swap(keylabel_, other->keylabel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata simpleEncryptedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = simpleEncryptedData_descriptor_;
  metadata.reflection = simpleEncryptedData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int signedData::kKeyLabelFieldNumber;
const int signedData::kSignatureFieldNumber;
const int signedData::kDataFieldNumber;
const int signedData::kVersionFieldNumber;
#endif  // !_MSC_VER

signedData::signedData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void signedData::InitAsDefaultInstance() {
}

signedData::signedData(const signedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void signedData::SharedCtor() {
  _cached_size_ = 0;
  keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

signedData::~signedData() {
  SharedDtor();
}

void signedData::SharedDtor() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (this != default_instance_) {
  }
}

void signedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* signedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return signedData_descriptor_;
}

const signedData& signedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

signedData* signedData::default_instance_ = NULL;

signedData* signedData::New() const {
  return new signedData;
}

void signedData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_keylabel()) {
      if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
        keylabel_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool signedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string keyLabel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keylabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->keylabel().data(), this->keylabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // optional bytes data = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_version;
        break;
      }

      // optional string version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void signedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string keyLabel = 1;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->keylabel(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signature(), output);
  }

  // optional bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->data(), output);
  }

  // optional string version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* signedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string keyLabel = 1;
  if (has_keylabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keylabel().data(), this->keylabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->keylabel(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // optional string version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int signedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string keyLabel = 1;
    if (has_keylabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->keylabel());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional string version = 4;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void signedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const signedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const signedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void signedData::MergeFrom(const signedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keylabel()) {
      set_keylabel(from.keylabel());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void signedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void signedData::CopyFrom(const signedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool signedData::IsInitialized() const {

  return true;
}

void signedData::Swap(signedData* other) {
  if (other != this) {
    std::swap(keylabel_, other->keylabel_);
    std::swap(signature_, other->signature_);
    std::swap(data_, other->data_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata signedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = signedData_descriptor_;
  metadata.reflection = signedData_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* payloadPart_addresseeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return payloadPart_addresseeType_descriptor_;
}
bool payloadPart_addresseeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const payloadPart_addresseeType payloadPart::T_FROM;
const payloadPart_addresseeType payloadPart::T_REPLY_TO;
const payloadPart_addresseeType payloadPart::T_TO;
const payloadPart_addresseeType payloadPart::T_CC;
const payloadPart_addresseeType payloadPart::T_BCC;
const payloadPart_addresseeType payloadPart::addresseeType_MIN;
const payloadPart_addresseeType payloadPart::addresseeType_MAX;
const int payloadPart::addresseeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int payloadPart_emailRecipient::kNameFieldNumber;
const int payloadPart_emailRecipient::kEmailFieldNumber;
const int payloadPart_emailRecipient::kTypeFieldNumber;
#endif  // !_MSC_VER

payloadPart_emailRecipient::payloadPart_emailRecipient()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void payloadPart_emailRecipient::InitAsDefaultInstance() {
}

payloadPart_emailRecipient::payloadPart_emailRecipient(const payloadPart_emailRecipient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void payloadPart_emailRecipient::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 2;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

payloadPart_emailRecipient::~payloadPart_emailRecipient() {
  SharedDtor();
}

void payloadPart_emailRecipient::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (this != default_instance_) {
  }
}

void payloadPart_emailRecipient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* payloadPart_emailRecipient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return payloadPart_emailRecipient_descriptor_;
}

const payloadPart_emailRecipient& payloadPart_emailRecipient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

payloadPart_emailRecipient* payloadPart_emailRecipient::default_instance_ = NULL;

payloadPart_emailRecipient* payloadPart_emailRecipient::New() const {
  return new payloadPart_emailRecipient;
}

void payloadPart_emailRecipient::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_email()) {
      if (email_ != &::google::protobuf::internal::kEmptyString) {
        email_->clear();
      }
    }
    type_ = 2;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool payloadPart_emailRecipient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_email;
        break;
      }

      // optional string email = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_email()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->email().data(), this->email().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mynigma::payloadPart_addresseeType_IsValid(value)) {
            set_type(static_cast< ::mynigma::payloadPart_addresseeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void payloadPart_emailRecipient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional string email = 2;
  if (has_email()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->email().data(), this->email().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->email(), output);
  }

  // optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* payloadPart_emailRecipient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string email = 2;
  if (has_email()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->email().data(), this->email().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->email(), target);
  }

  // optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int payloadPart_emailRecipient::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string email = 2;
    if (has_email()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->email());
    }

    // optional .mynigma.payloadPart.addresseeType type = 3 [default = T_TO];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void payloadPart_emailRecipient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const payloadPart_emailRecipient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const payloadPart_emailRecipient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void payloadPart_emailRecipient::MergeFrom(const payloadPart_emailRecipient& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_email()) {
      set_email(from.email());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void payloadPart_emailRecipient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void payloadPart_emailRecipient::CopyFrom(const payloadPart_emailRecipient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool payloadPart_emailRecipient::IsInitialized() const {

  return true;
}

void payloadPart_emailRecipient::Swap(payloadPart_emailRecipient* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(email_, other->email_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata payloadPart_emailRecipient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = payloadPart_emailRecipient_descriptor_;
  metadata.reflection = payloadPart_emailRecipient_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int payloadPart_fileAttachment::kFilenameFieldNumber;
const int payloadPart_fileAttachment::kContentIDFieldNumber;
const int payloadPart_fileAttachment::kSizeFieldNumber;
const int payloadPart_fileAttachment::kHashedValueFieldNumber;
const int payloadPart_fileAttachment::kPartIDFieldNumber;
const int payloadPart_fileAttachment::kRemoteURLFieldNumber;
const int payloadPart_fileAttachment::kIsInlineFieldNumber;
const int payloadPart_fileAttachment::kContentTypeFieldNumber;
#endif  // !_MSC_VER

payloadPart_fileAttachment::payloadPart_fileAttachment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void payloadPart_fileAttachment::InitAsDefaultInstance() {
}

payloadPart_fileAttachment::payloadPart_fileAttachment(const payloadPart_fileAttachment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void payloadPart_fileAttachment::SharedCtor() {
  _cached_size_ = 0;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  contentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  size_ = 0;
  hashedvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  partid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  remoteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isinline_ = false;
  contenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

payloadPart_fileAttachment::~payloadPart_fileAttachment() {
  SharedDtor();
}

void payloadPart_fileAttachment::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (contentid_ != &::google::protobuf::internal::kEmptyString) {
    delete contentid_;
  }
  if (hashedvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete hashedvalue_;
  }
  if (partid_ != &::google::protobuf::internal::kEmptyString) {
    delete partid_;
  }
  if (remoteurl_ != &::google::protobuf::internal::kEmptyString) {
    delete remoteurl_;
  }
  if (contenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete contenttype_;
  }
  if (this != default_instance_) {
  }
}

void payloadPart_fileAttachment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* payloadPart_fileAttachment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return payloadPart_fileAttachment_descriptor_;
}

const payloadPart_fileAttachment& payloadPart_fileAttachment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

payloadPart_fileAttachment* payloadPart_fileAttachment::default_instance_ = NULL;

payloadPart_fileAttachment* payloadPart_fileAttachment::New() const {
  return new payloadPart_fileAttachment;
}

void payloadPart_fileAttachment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::kEmptyString) {
        filename_->clear();
      }
    }
    if (has_contentid()) {
      if (contentid_ != &::google::protobuf::internal::kEmptyString) {
        contentid_->clear();
      }
    }
    size_ = 0;
    if (has_hashedvalue()) {
      if (hashedvalue_ != &::google::protobuf::internal::kEmptyString) {
        hashedvalue_->clear();
      }
    }
    if (has_partid()) {
      if (partid_ != &::google::protobuf::internal::kEmptyString) {
        partid_->clear();
      }
    }
    if (has_remoteurl()) {
      if (remoteurl_ != &::google::protobuf::internal::kEmptyString) {
        remoteurl_->clear();
      }
    }
    isinline_ = false;
    if (has_contenttype()) {
      if (contenttype_ != &::google::protobuf::internal::kEmptyString) {
        contenttype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool payloadPart_fileAttachment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filename = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_contentID;
        break;
      }

      // optional string contentID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contentID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contentid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->contentid().data(), this->contentid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional int32 size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_hashedValue;
        break;
      }

      // optional bytes hashedValue = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hashedValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hashedvalue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_partID;
        break;
      }

      // optional string partID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_partID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->partid().data(), this->partid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_remoteURL;
        break;
      }

      // optional string remoteURL = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_remoteURL:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remoteurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->remoteurl().data(), this->remoteurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_isInline;
        break;
      }

      // optional bool isInline = 7 [default = false];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isInline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isinline_)));
          set_has_isinline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_contentType;
        break;
      }

      // optional string contentType = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contentType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contenttype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->contenttype().data(), this->contenttype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void payloadPart_fileAttachment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filename(), output);
  }

  // optional string contentID = 2;
  if (has_contentid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->contentid().data(), this->contentid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->contentid(), output);
  }

  // optional int32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->size(), output);
  }

  // optional bytes hashedValue = 4;
  if (has_hashedvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->hashedvalue(), output);
  }

  // optional string partID = 5;
  if (has_partid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partid().data(), this->partid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->partid(), output);
  }

  // optional string remoteURL = 6;
  if (has_remoteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->remoteurl().data(), this->remoteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->remoteurl(), output);
  }

  // optional bool isInline = 7 [default = false];
  if (has_isinline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->isinline(), output);
  }

  // optional string contentType = 8;
  if (has_contenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->contenttype().data(), this->contenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->contenttype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* payloadPart_fileAttachment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filename(), target);
  }

  // optional string contentID = 2;
  if (has_contentid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->contentid().data(), this->contentid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->contentid(), target);
  }

  // optional int32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->size(), target);
  }

  // optional bytes hashedValue = 4;
  if (has_hashedvalue()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->hashedvalue(), target);
  }

  // optional string partID = 5;
  if (has_partid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->partid().data(), this->partid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->partid(), target);
  }

  // optional string remoteURL = 6;
  if (has_remoteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->remoteurl().data(), this->remoteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->remoteurl(), target);
  }

  // optional bool isInline = 7 [default = false];
  if (has_isinline()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->isinline(), target);
  }

  // optional string contentType = 8;
  if (has_contenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->contenttype().data(), this->contenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->contenttype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int payloadPart_fileAttachment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filename = 1;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // optional string contentID = 2;
    if (has_contentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contentid());
    }

    // optional int32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

    // optional bytes hashedValue = 4;
    if (has_hashedvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hashedvalue());
    }

    // optional string partID = 5;
    if (has_partid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->partid());
    }

    // optional string remoteURL = 6;
    if (has_remoteurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remoteurl());
    }

    // optional bool isInline = 7 [default = false];
    if (has_isinline()) {
      total_size += 1 + 1;
    }

    // optional string contentType = 8;
    if (has_contenttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contenttype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void payloadPart_fileAttachment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const payloadPart_fileAttachment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const payloadPart_fileAttachment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void payloadPart_fileAttachment::MergeFrom(const payloadPart_fileAttachment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_contentid()) {
      set_contentid(from.contentid());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_hashedvalue()) {
      set_hashedvalue(from.hashedvalue());
    }
    if (from.has_partid()) {
      set_partid(from.partid());
    }
    if (from.has_remoteurl()) {
      set_remoteurl(from.remoteurl());
    }
    if (from.has_isinline()) {
      set_isinline(from.isinline());
    }
    if (from.has_contenttype()) {
      set_contenttype(from.contenttype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void payloadPart_fileAttachment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void payloadPart_fileAttachment::CopyFrom(const payloadPart_fileAttachment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool payloadPart_fileAttachment::IsInitialized() const {

  return true;
}

void payloadPart_fileAttachment::Swap(payloadPart_fileAttachment* other) {
  if (other != this) {
    std::swap(filename_, other->filename_);
    std::swap(contentid_, other->contentid_);
    std::swap(size_, other->size_);
    std::swap(hashedvalue_, other->hashedvalue_);
    std::swap(partid_, other->partid_);
    std::swap(remoteurl_, other->remoteurl_);
    std::swap(isinline_, other->isinline_);
    std::swap(contenttype_, other->contenttype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata payloadPart_fileAttachment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = payloadPart_fileAttachment_descriptor_;
  metadata.reflection = payloadPart_fileAttachment_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int payloadPart::kBodyFieldNumber;
const int payloadPart::kHtmlBodyFieldNumber;
const int payloadPart::kSubjectFieldNumber;
const int payloadPart::kDateSentFieldNumber;
const int payloadPart::kDeclarationFieldNumber;
const int payloadPart::kRecipientsFieldNumber;
const int payloadPart::kAttachmentsFieldNumber;
#endif  // !_MSC_VER

payloadPart::payloadPart()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void payloadPart::InitAsDefaultInstance() {
}

payloadPart::payloadPart(const payloadPart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void payloadPart::SharedCtor() {
  _cached_size_ = 0;
  body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  htmlbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  subject_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  datesent_ = 0;
  declaration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

payloadPart::~payloadPart() {
  SharedDtor();
}

void payloadPart::SharedDtor() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
    delete htmlbody_;
  }
  if (subject_ != &::google::protobuf::internal::kEmptyString) {
    delete subject_;
  }
  if (declaration_ != &::google::protobuf::internal::kEmptyString) {
    delete declaration_;
  }
  if (this != default_instance_) {
  }
}

void payloadPart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* payloadPart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return payloadPart_descriptor_;
}

const payloadPart& payloadPart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_encryption_2eproto();
  return *default_instance_;
}

payloadPart* payloadPart::default_instance_ = NULL;

payloadPart* payloadPart::New() const {
  return new payloadPart;
}

void payloadPart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_body()) {
      if (body_ != &::google::protobuf::internal::kEmptyString) {
        body_->clear();
      }
    }
    if (has_htmlbody()) {
      if (htmlbody_ != &::google::protobuf::internal::kEmptyString) {
        htmlbody_->clear();
      }
    }
    if (has_subject()) {
      if (subject_ != &::google::protobuf::internal::kEmptyString) {
        subject_->clear();
      }
    }
    datesent_ = 0;
    if (has_declaration()) {
      if (declaration_ != &::google::protobuf::internal::kEmptyString) {
        declaration_->clear();
      }
    }
  }
  recipients_.Clear();
  attachments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool payloadPart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string body = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_body()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->body().data(), this->body().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_htmlBody;
        break;
      }

      // optional string htmlBody = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_htmlBody:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_htmlbody()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->htmlbody().data(), this->htmlbody().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_subject;
        break;
      }

      // optional string subject = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_subject:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_subject()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->subject().data(), this->subject().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_dateSent;
        break;
      }

      // optional int32 dateSent = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dateSent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datesent_)));
          set_has_datesent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recipients;
        break;
      }

      // repeated .mynigma.payloadPart.emailRecipient recipients = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recipients:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_recipients()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_recipients;
        if (input->ExpectTag(50)) goto parse_attachments;
        break;
      }

      // repeated .mynigma.payloadPart.fileAttachment attachments = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attachments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_attachments()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_attachments;
        if (input->ExpectTag(58)) goto parse_declaration;
        break;
      }

      // optional bytes declaration = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_declaration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_declaration()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void payloadPart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string body = 1;
  if (has_body()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->body().data(), this->body().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->body(), output);
  }

  // optional string htmlBody = 2;
  if (has_htmlbody()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->htmlbody().data(), this->htmlbody().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->htmlbody(), output);
  }

  // optional string subject = 3;
  if (has_subject()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subject().data(), this->subject().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->subject(), output);
  }

  // optional int32 dateSent = 4;
  if (has_datesent()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->datesent(), output);
  }

  // repeated .mynigma.payloadPart.emailRecipient recipients = 5;
  for (int i = 0; i < this->recipients_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->recipients(i), output);
  }

  // repeated .mynigma.payloadPart.fileAttachment attachments = 6;
  for (int i = 0; i < this->attachments_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->attachments(i), output);
  }

  // optional bytes declaration = 7;
  if (has_declaration()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->declaration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* payloadPart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string body = 1;
  if (has_body()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->body().data(), this->body().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->body(), target);
  }

  // optional string htmlBody = 2;
  if (has_htmlbody()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->htmlbody().data(), this->htmlbody().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->htmlbody(), target);
  }

  // optional string subject = 3;
  if (has_subject()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->subject().data(), this->subject().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->subject(), target);
  }

  // optional int32 dateSent = 4;
  if (has_datesent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->datesent(), target);
  }

  // repeated .mynigma.payloadPart.emailRecipient recipients = 5;
  for (int i = 0; i < this->recipients_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->recipients(i), target);
  }

  // repeated .mynigma.payloadPart.fileAttachment attachments = 6;
  for (int i = 0; i < this->attachments_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->attachments(i), target);
  }

  // optional bytes declaration = 7;
  if (has_declaration()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->declaration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int payloadPart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string body = 1;
    if (has_body()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->body());
    }

    // optional string htmlBody = 2;
    if (has_htmlbody()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->htmlbody());
    }

    // optional string subject = 3;
    if (has_subject()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->subject());
    }

    // optional int32 dateSent = 4;
    if (has_datesent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datesent());
    }

    // optional bytes declaration = 7;
    if (has_declaration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->declaration());
    }

  }
  // repeated .mynigma.payloadPart.emailRecipient recipients = 5;
  total_size += 1 * this->recipients_size();
  for (int i = 0; i < this->recipients_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->recipients(i));
  }

  // repeated .mynigma.payloadPart.fileAttachment attachments = 6;
  total_size += 1 * this->attachments_size();
  for (int i = 0; i < this->attachments_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attachments(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void payloadPart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const payloadPart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const payloadPart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void payloadPart::MergeFrom(const payloadPart& from) {
  GOOGLE_CHECK_NE(&from, this);
  recipients_.MergeFrom(from.recipients_);
  attachments_.MergeFrom(from.attachments_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_body()) {
      set_body(from.body());
    }
    if (from.has_htmlbody()) {
      set_htmlbody(from.htmlbody());
    }
    if (from.has_subject()) {
      set_subject(from.subject());
    }
    if (from.has_datesent()) {
      set_datesent(from.datesent());
    }
    if (from.has_declaration()) {
      set_declaration(from.declaration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void payloadPart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void payloadPart::CopyFrom(const payloadPart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool payloadPart::IsInitialized() const {

  return true;
}

void payloadPart::Swap(payloadPart* other) {
  if (other != this) {
    std::swap(body_, other->body_);
    std::swap(htmlbody_, other->htmlbody_);
    std::swap(subject_, other->subject_);
    std::swap(datesent_, other->datesent_);
    std::swap(declaration_, other->declaration_);
    recipients_.Swap(&other->recipients_);
    attachments_.Swap(&other->attachments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata payloadPart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = payloadPart_descriptor_;
  metadata.reflection = payloadPart_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mynigma

// @@protoc_insertion_point(global_scope)
