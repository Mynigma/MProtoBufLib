// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backupData.proto

#ifndef PROTOBUF_backupData_2eproto__INCLUDED
#define PROTOBUF_backupData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mynigma {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_backupData_2eproto();
void protobuf_AssignDesc_backupData_2eproto();
void protobuf_ShutdownFile_backupData_2eproto();

class privateKey;
class publicKey;
class keyExpectation;
class plainBackupData;
class backupPasswordFileWrapper;

// ===================================================================

class privateKey : public ::google::protobuf::Message {
 public:
  privateKey();
  virtual ~privateKey();

  privateKey(const privateKey& from);

  inline privateKey& operator=(const privateKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const privateKey& default_instance();

  void Swap(privateKey* other);

  // implements Message ----------------------------------------------

  privateKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const privateKey& from);
  void MergeFrom(const privateKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyLabel = 1;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 1;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int64 dateAnchored = 2;
  inline bool has_dateanchored() const;
  inline void clear_dateanchored();
  static const int kDateAnchoredFieldNumber = 2;
  inline ::google::protobuf::int64 dateanchored() const;
  inline void set_dateanchored(::google::protobuf::int64 value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes encrKeyData = 4;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 4;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // optional bytes verKeyData = 5;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 5;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // repeated string currentKeyForEmails = 6;
  inline int currentkeyforemails_size() const;
  inline void clear_currentkeyforemails();
  static const int kCurrentKeyForEmailsFieldNumber = 6;
  inline const ::std::string& currentkeyforemails(int index) const;
  inline ::std::string* mutable_currentkeyforemails(int index);
  inline void set_currentkeyforemails(int index, const ::std::string& value);
  inline void set_currentkeyforemails(int index, const char* value);
  inline void set_currentkeyforemails(int index, const char* value, size_t size);
  inline ::std::string* add_currentkeyforemails();
  inline void add_currentkeyforemails(const ::std::string& value);
  inline void add_currentkeyforemails(const char* value);
  inline void add_currentkeyforemails(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentkeyforemails() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentkeyforemails();

  // repeated string keyForEmails = 7;
  inline int keyforemails_size() const;
  inline void clear_keyforemails();
  static const int kKeyForEmailsFieldNumber = 7;
  inline const ::std::string& keyforemails(int index) const;
  inline ::std::string* mutable_keyforemails(int index);
  inline void set_keyforemails(int index, const ::std::string& value);
  inline void set_keyforemails(int index, const char* value);
  inline void set_keyforemails(int index, const char* value, size_t size);
  inline ::std::string* add_keyforemails();
  inline void add_keyforemails(const ::std::string& value);
  inline void add_keyforemails(const char* value);
  inline void add_keyforemails(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keyforemails() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keyforemails();

  // repeated string keyForDevicesWithUUID = 8;
  inline int keyfordeviceswithuuid_size() const;
  inline void clear_keyfordeviceswithuuid();
  static const int kKeyForDevicesWithUUIDFieldNumber = 8;
  inline const ::std::string& keyfordeviceswithuuid(int index) const;
  inline ::std::string* mutable_keyfordeviceswithuuid(int index);
  inline void set_keyfordeviceswithuuid(int index, const ::std::string& value);
  inline void set_keyfordeviceswithuuid(int index, const char* value);
  inline void set_keyfordeviceswithuuid(int index, const char* value, size_t size);
  inline ::std::string* add_keyfordeviceswithuuid();
  inline void add_keyfordeviceswithuuid(const ::std::string& value);
  inline void add_keyfordeviceswithuuid(const char* value);
  inline void add_keyfordeviceswithuuid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keyfordeviceswithuuid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keyfordeviceswithuuid();

  // repeated int64 datesCurrentKeysAnchored = 15;
  inline int datescurrentkeysanchored_size() const;
  inline void clear_datescurrentkeysanchored();
  static const int kDatesCurrentKeysAnchoredFieldNumber = 15;
  inline ::google::protobuf::int64 datescurrentkeysanchored(int index) const;
  inline void set_datescurrentkeysanchored(int index, ::google::protobuf::int64 value);
  inline void add_datescurrentkeysanchored(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      datescurrentkeysanchored() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_datescurrentkeysanchored();

  // optional bytes decrKeyData = 9;
  inline bool has_decrkeydata() const;
  inline void clear_decrkeydata();
  static const int kDecrKeyDataFieldNumber = 9;
  inline const ::std::string& decrkeydata() const;
  inline void set_decrkeydata(const ::std::string& value);
  inline void set_decrkeydata(const char* value);
  inline void set_decrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_decrkeydata();
  inline ::std::string* release_decrkeydata();
  inline void set_allocated_decrkeydata(::std::string* decrkeydata);

  // optional bytes signKeyData = 10;
  inline bool has_signkeydata() const;
  inline void clear_signkeydata();
  static const int kSignKeyDataFieldNumber = 10;
  inline const ::std::string& signkeydata() const;
  inline void set_signkeydata(const ::std::string& value);
  inline void set_signkeydata(const char* value);
  inline void set_signkeydata(const void* value, size_t size);
  inline ::std::string* mutable_signkeydata();
  inline ::std::string* release_signkeydata();
  inline void set_allocated_signkeydata(::std::string* signkeydata);

  // optional bool isCompromised = 11;
  inline bool has_iscompromised() const;
  inline void clear_iscompromised();
  static const int kIsCompromisedFieldNumber = 11;
  inline bool iscompromised() const;
  inline void set_iscompromised(bool value);

  // optional int64 dateCreated = 12;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 12;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);

  // repeated string introducesKeys = 13;
  inline int introduceskeys_size() const;
  inline void clear_introduceskeys();
  static const int kIntroducesKeysFieldNumber = 13;
  inline const ::std::string& introduceskeys(int index) const;
  inline ::std::string* mutable_introduceskeys(int index);
  inline void set_introduceskeys(int index, const ::std::string& value);
  inline void set_introduceskeys(int index, const char* value);
  inline void set_introduceskeys(int index, const char* value, size_t size);
  inline ::std::string* add_introduceskeys();
  inline void add_introduceskeys(const ::std::string& value);
  inline void add_introduceskeys(const char* value);
  inline void add_introduceskeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& introduceskeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_introduceskeys();

  // repeated string isIntroducedByKeys = 14;
  inline int isintroducedbykeys_size() const;
  inline void clear_isintroducedbykeys();
  static const int kIsIntroducedByKeysFieldNumber = 14;
  inline const ::std::string& isintroducedbykeys(int index) const;
  inline ::std::string* mutable_isintroducedbykeys(int index);
  inline void set_isintroducedbykeys(int index, const ::std::string& value);
  inline void set_isintroducedbykeys(int index, const char* value);
  inline void set_isintroducedbykeys(int index, const char* value, size_t size);
  inline ::std::string* add_isintroducedbykeys();
  inline void add_isintroducedbykeys(const ::std::string& value);
  inline void add_isintroducedbykeys(const char* value);
  inline void add_isintroducedbykeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& isintroducedbykeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_isintroducedbykeys();

  // @@protoc_insertion_point(class_scope:mynigma.privateKey)
 private:
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_dateanchored();
  inline void clear_has_dateanchored();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_decrkeydata();
  inline void clear_has_decrkeydata();
  inline void set_has_signkeydata();
  inline void clear_has_signkeydata();
  inline void set_has_iscompromised();
  inline void clear_has_iscompromised();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keylabel_;
  ::google::protobuf::int64 dateanchored_;
  ::std::string* version_;
  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentkeyforemails_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keyforemails_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keyfordeviceswithuuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > datescurrentkeysanchored_;
  ::std::string* decrkeydata_;
  ::std::string* signkeydata_;
  ::google::protobuf::int64 datecreated_;
  ::google::protobuf::RepeatedPtrField< ::std::string> introduceskeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> isintroducedbykeys_;
  bool iscompromised_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_backupData_2eproto();
  friend void protobuf_AssignDesc_backupData_2eproto();
  friend void protobuf_ShutdownFile_backupData_2eproto();

  void InitAsDefaultInstance();
  static privateKey* default_instance_;
};
// -------------------------------------------------------------------

class publicKey : public ::google::protobuf::Message {
 public:
  publicKey();
  virtual ~publicKey();

  publicKey(const publicKey& from);

  inline publicKey& operator=(const publicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const publicKey& default_instance();

  void Swap(publicKey* other);

  // implements Message ----------------------------------------------

  publicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const publicKey& from);
  void MergeFrom(const publicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyLabel = 1;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 1;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int64 dateAnchored = 2;
  inline bool has_dateanchored() const;
  inline void clear_dateanchored();
  static const int kDateAnchoredFieldNumber = 2;
  inline ::google::protobuf::int64 dateanchored() const;
  inline void set_dateanchored(::google::protobuf::int64 value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes encrKeyData = 4;
  inline bool has_encrkeydata() const;
  inline void clear_encrkeydata();
  static const int kEncrKeyDataFieldNumber = 4;
  inline const ::std::string& encrkeydata() const;
  inline void set_encrkeydata(const ::std::string& value);
  inline void set_encrkeydata(const char* value);
  inline void set_encrkeydata(const void* value, size_t size);
  inline ::std::string* mutable_encrkeydata();
  inline ::std::string* release_encrkeydata();
  inline void set_allocated_encrkeydata(::std::string* encrkeydata);

  // optional bytes verKeyData = 5;
  inline bool has_verkeydata() const;
  inline void clear_verkeydata();
  static const int kVerKeyDataFieldNumber = 5;
  inline const ::std::string& verkeydata() const;
  inline void set_verkeydata(const ::std::string& value);
  inline void set_verkeydata(const char* value);
  inline void set_verkeydata(const void* value, size_t size);
  inline ::std::string* mutable_verkeydata();
  inline ::std::string* release_verkeydata();
  inline void set_allocated_verkeydata(::std::string* verkeydata);

  // repeated string currentKeyForEmails = 6;
  inline int currentkeyforemails_size() const;
  inline void clear_currentkeyforemails();
  static const int kCurrentKeyForEmailsFieldNumber = 6;
  inline const ::std::string& currentkeyforemails(int index) const;
  inline ::std::string* mutable_currentkeyforemails(int index);
  inline void set_currentkeyforemails(int index, const ::std::string& value);
  inline void set_currentkeyforemails(int index, const char* value);
  inline void set_currentkeyforemails(int index, const char* value, size_t size);
  inline ::std::string* add_currentkeyforemails();
  inline void add_currentkeyforemails(const ::std::string& value);
  inline void add_currentkeyforemails(const char* value);
  inline void add_currentkeyforemails(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& currentkeyforemails() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_currentkeyforemails();

  // repeated string keyForEmails = 7;
  inline int keyforemails_size() const;
  inline void clear_keyforemails();
  static const int kKeyForEmailsFieldNumber = 7;
  inline const ::std::string& keyforemails(int index) const;
  inline ::std::string* mutable_keyforemails(int index);
  inline void set_keyforemails(int index, const ::std::string& value);
  inline void set_keyforemails(int index, const char* value);
  inline void set_keyforemails(int index, const char* value, size_t size);
  inline ::std::string* add_keyforemails();
  inline void add_keyforemails(const ::std::string& value);
  inline void add_keyforemails(const char* value);
  inline void add_keyforemails(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keyforemails() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keyforemails();

  // repeated string keyForDevicesWithUUID = 8;
  inline int keyfordeviceswithuuid_size() const;
  inline void clear_keyfordeviceswithuuid();
  static const int kKeyForDevicesWithUUIDFieldNumber = 8;
  inline const ::std::string& keyfordeviceswithuuid(int index) const;
  inline ::std::string* mutable_keyfordeviceswithuuid(int index);
  inline void set_keyfordeviceswithuuid(int index, const ::std::string& value);
  inline void set_keyfordeviceswithuuid(int index, const char* value);
  inline void set_keyfordeviceswithuuid(int index, const char* value, size_t size);
  inline ::std::string* add_keyfordeviceswithuuid();
  inline void add_keyfordeviceswithuuid(const ::std::string& value);
  inline void add_keyfordeviceswithuuid(const char* value);
  inline void add_keyfordeviceswithuuid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keyfordeviceswithuuid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keyfordeviceswithuuid();

  // repeated int64 datesCurrentKeysAnchored = 15;
  inline int datescurrentkeysanchored_size() const;
  inline void clear_datescurrentkeysanchored();
  static const int kDatesCurrentKeysAnchoredFieldNumber = 15;
  inline ::google::protobuf::int64 datescurrentkeysanchored(int index) const;
  inline void set_datescurrentkeysanchored(int index, ::google::protobuf::int64 value);
  inline void add_datescurrentkeysanchored(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      datescurrentkeysanchored() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_datescurrentkeysanchored();

  // optional bool isCompromised = 11;
  inline bool has_iscompromised() const;
  inline void clear_iscompromised();
  static const int kIsCompromisedFieldNumber = 11;
  inline bool iscompromised() const;
  inline void set_iscompromised(bool value);

  // optional int64 dateCreated = 12;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 12;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);

  // repeated string introducesKeys = 13;
  inline int introduceskeys_size() const;
  inline void clear_introduceskeys();
  static const int kIntroducesKeysFieldNumber = 13;
  inline const ::std::string& introduceskeys(int index) const;
  inline ::std::string* mutable_introduceskeys(int index);
  inline void set_introduceskeys(int index, const ::std::string& value);
  inline void set_introduceskeys(int index, const char* value);
  inline void set_introduceskeys(int index, const char* value, size_t size);
  inline ::std::string* add_introduceskeys();
  inline void add_introduceskeys(const ::std::string& value);
  inline void add_introduceskeys(const char* value);
  inline void add_introduceskeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& introduceskeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_introduceskeys();

  // repeated string isIntroducedByKeys = 14;
  inline int isintroducedbykeys_size() const;
  inline void clear_isintroducedbykeys();
  static const int kIsIntroducedByKeysFieldNumber = 14;
  inline const ::std::string& isintroducedbykeys(int index) const;
  inline ::std::string* mutable_isintroducedbykeys(int index);
  inline void set_isintroducedbykeys(int index, const ::std::string& value);
  inline void set_isintroducedbykeys(int index, const char* value);
  inline void set_isintroducedbykeys(int index, const char* value, size_t size);
  inline ::std::string* add_isintroducedbykeys();
  inline void add_isintroducedbykeys(const ::std::string& value);
  inline void add_isintroducedbykeys(const char* value);
  inline void add_isintroducedbykeys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& isintroducedbykeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_isintroducedbykeys();

  // @@protoc_insertion_point(class_scope:mynigma.publicKey)
 private:
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_dateanchored();
  inline void clear_has_dateanchored();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_encrkeydata();
  inline void clear_has_encrkeydata();
  inline void set_has_verkeydata();
  inline void clear_has_verkeydata();
  inline void set_has_iscompromised();
  inline void clear_has_iscompromised();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keylabel_;
  ::google::protobuf::int64 dateanchored_;
  ::std::string* version_;
  ::std::string* encrkeydata_;
  ::std::string* verkeydata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> currentkeyforemails_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keyforemails_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keyfordeviceswithuuid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > datescurrentkeysanchored_;
  ::google::protobuf::int64 datecreated_;
  ::google::protobuf::RepeatedPtrField< ::std::string> introduceskeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> isintroducedbykeys_;
  bool iscompromised_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_backupData_2eproto();
  friend void protobuf_AssignDesc_backupData_2eproto();
  friend void protobuf_ShutdownFile_backupData_2eproto();

  void InitAsDefaultInstance();
  static publicKey* default_instance_;
};
// -------------------------------------------------------------------

class keyExpectation : public ::google::protobuf::Message {
 public:
  keyExpectation();
  virtual ~keyExpectation();

  keyExpectation(const keyExpectation& from);

  inline keyExpectation& operator=(const keyExpectation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const keyExpectation& default_instance();

  void Swap(keyExpectation* other);

  // implements Message ----------------------------------------------

  keyExpectation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const keyExpectation& from);
  void MergeFrom(const keyExpectation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fromAddress = 1;
  inline bool has_fromaddress() const;
  inline void clear_fromaddress();
  static const int kFromAddressFieldNumber = 1;
  inline const ::std::string& fromaddress() const;
  inline void set_fromaddress(const ::std::string& value);
  inline void set_fromaddress(const char* value);
  inline void set_fromaddress(const char* value, size_t size);
  inline ::std::string* mutable_fromaddress();
  inline ::std::string* release_fromaddress();
  inline void set_allocated_fromaddress(::std::string* fromaddress);

  // optional string toAddress = 2;
  inline bool has_toaddress() const;
  inline void clear_toaddress();
  static const int kToAddressFieldNumber = 2;
  inline const ::std::string& toaddress() const;
  inline void set_toaddress(const ::std::string& value);
  inline void set_toaddress(const char* value);
  inline void set_toaddress(const char* value, size_t size);
  inline ::std::string* mutable_toaddress();
  inline ::std::string* release_toaddress();
  inline void set_allocated_toaddress(::std::string* toaddress);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string keyLabel = 4;
  inline bool has_keylabel() const;
  inline void clear_keylabel();
  static const int kKeyLabelFieldNumber = 4;
  inline const ::std::string& keylabel() const;
  inline void set_keylabel(const ::std::string& value);
  inline void set_keylabel(const char* value);
  inline void set_keylabel(const char* value, size_t size);
  inline ::std::string* mutable_keylabel();
  inline ::std::string* release_keylabel();
  inline void set_allocated_keylabel(::std::string* keylabel);

  // optional int64 dateCreated = 5;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 5;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mynigma.keyExpectation)
 private:
  inline void set_has_fromaddress();
  inline void clear_has_fromaddress();
  inline void set_has_toaddress();
  inline void clear_has_toaddress();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_keylabel();
  inline void clear_has_keylabel();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fromaddress_;
  ::std::string* toaddress_;
  ::std::string* version_;
  ::std::string* keylabel_;
  ::google::protobuf::int64 datecreated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_backupData_2eproto();
  friend void protobuf_AssignDesc_backupData_2eproto();
  friend void protobuf_ShutdownFile_backupData_2eproto();

  void InitAsDefaultInstance();
  static keyExpectation* default_instance_;
};
// -------------------------------------------------------------------

class plainBackupData : public ::google::protobuf::Message {
 public:
  plainBackupData();
  virtual ~plainBackupData();

  plainBackupData(const plainBackupData& from);

  inline plainBackupData& operator=(const plainBackupData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const plainBackupData& default_instance();

  void Swap(plainBackupData* other);

  // implements Message ----------------------------------------------

  plainBackupData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const plainBackupData& from);
  void MergeFrom(const plainBackupData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mynigma.privateKey privKeys = 1;
  inline int privkeys_size() const;
  inline void clear_privkeys();
  static const int kPrivKeysFieldNumber = 1;
  inline const ::mynigma::privateKey& privkeys(int index) const;
  inline ::mynigma::privateKey* mutable_privkeys(int index);
  inline ::mynigma::privateKey* add_privkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >&
      privkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >*
      mutable_privkeys();

  // repeated .mynigma.publicKey pubKeys = 2;
  inline int pubkeys_size() const;
  inline void clear_pubkeys();
  static const int kPubKeysFieldNumber = 2;
  inline const ::mynigma::publicKey& pubkeys(int index) const;
  inline ::mynigma::publicKey* mutable_pubkeys(int index);
  inline ::mynigma::publicKey* add_pubkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >&
      pubkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >*
      mutable_pubkeys();

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated .mynigma.keyExpectation keyExpectations = 4;
  inline int keyexpectations_size() const;
  inline void clear_keyexpectations();
  static const int kKeyExpectationsFieldNumber = 4;
  inline const ::mynigma::keyExpectation& keyexpectations(int index) const;
  inline ::mynigma::keyExpectation* mutable_keyexpectations(int index);
  inline ::mynigma::keyExpectation* add_keyexpectations();
  inline const ::google::protobuf::RepeatedPtrField< ::mynigma::keyExpectation >&
      keyexpectations() const;
  inline ::google::protobuf::RepeatedPtrField< ::mynigma::keyExpectation >*
      mutable_keyexpectations();

  // optional string integrityCheckString = 5;
  inline bool has_integritycheckstring() const;
  inline void clear_integritycheckstring();
  static const int kIntegrityCheckStringFieldNumber = 5;
  inline const ::std::string& integritycheckstring() const;
  inline void set_integritycheckstring(const ::std::string& value);
  inline void set_integritycheckstring(const char* value);
  inline void set_integritycheckstring(const char* value, size_t size);
  inline ::std::string* mutable_integritycheckstring();
  inline ::std::string* release_integritycheckstring();
  inline void set_allocated_integritycheckstring(::std::string* integritycheckstring);

  // @@protoc_insertion_point(class_scope:mynigma.plainBackupData)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_integritycheckstring();
  inline void clear_has_integritycheckstring();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey > privkeys_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey > pubkeys_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::mynigma::keyExpectation > keyexpectations_;
  ::std::string* integritycheckstring_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_backupData_2eproto();
  friend void protobuf_AssignDesc_backupData_2eproto();
  friend void protobuf_ShutdownFile_backupData_2eproto();

  void InitAsDefaultInstance();
  static plainBackupData* default_instance_;
};
// -------------------------------------------------------------------

class backupPasswordFileWrapper : public ::google::protobuf::Message {
 public:
  backupPasswordFileWrapper();
  virtual ~backupPasswordFileWrapper();

  backupPasswordFileWrapper(const backupPasswordFileWrapper& from);

  inline backupPasswordFileWrapper& operator=(const backupPasswordFileWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const backupPasswordFileWrapper& default_instance();

  void Swap(backupPasswordFileWrapper* other);

  // implements Message ----------------------------------------------

  backupPasswordFileWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const backupPasswordFileWrapper& from);
  void MergeFrom(const backupPasswordFileWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payloadData = 1;
  inline bool has_payloaddata() const;
  inline void clear_payloaddata();
  static const int kPayloadDataFieldNumber = 1;
  inline const ::std::string& payloaddata() const;
  inline void set_payloaddata(const ::std::string& value);
  inline void set_payloaddata(const char* value);
  inline void set_payloaddata(const void* value, size_t size);
  inline ::std::string* mutable_payloaddata();
  inline ::std::string* release_payloaddata();
  inline void set_allocated_payloaddata(::std::string* payloaddata);

  // optional bool hasPassword = 2;
  inline bool has_haspassword() const;
  inline void clear_haspassword();
  static const int kHasPasswordFieldNumber = 2;
  inline bool haspassword() const;
  inline void set_haspassword(bool value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes passwordSalt = 6;
  inline bool has_passwordsalt() const;
  inline void clear_passwordsalt();
  static const int kPasswordSaltFieldNumber = 6;
  inline const ::std::string& passwordsalt() const;
  inline void set_passwordsalt(const ::std::string& value);
  inline void set_passwordsalt(const char* value);
  inline void set_passwordsalt(const void* value, size_t size);
  inline ::std::string* mutable_passwordsalt();
  inline ::std::string* release_passwordsalt();
  inline void set_allocated_passwordsalt(::std::string* passwordsalt);

  // @@protoc_insertion_point(class_scope:mynigma.backupPasswordFileWrapper)
 private:
  inline void set_has_payloaddata();
  inline void clear_has_payloaddata();
  inline void set_has_haspassword();
  inline void clear_has_haspassword();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_passwordsalt();
  inline void clear_has_passwordsalt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* payloaddata_;
  ::std::string* version_;
  ::std::string* passwordsalt_;
  bool haspassword_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_backupData_2eproto();
  friend void protobuf_AssignDesc_backupData_2eproto();
  friend void protobuf_ShutdownFile_backupData_2eproto();

  void InitAsDefaultInstance();
  static backupPasswordFileWrapper* default_instance_;
};
// ===================================================================


// ===================================================================

// privateKey

// optional string keyLabel = 1;
inline bool privateKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void privateKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void privateKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void privateKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& privateKey::keylabel() const {
  return *keylabel_;
}
inline void privateKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void privateKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void privateKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* privateKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 dateAnchored = 2;
inline bool privateKey::has_dateanchored() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void privateKey::set_has_dateanchored() {
  _has_bits_[0] |= 0x00000002u;
}
inline void privateKey::clear_has_dateanchored() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void privateKey::clear_dateanchored() {
  dateanchored_ = GOOGLE_LONGLONG(0);
  clear_has_dateanchored();
}
inline ::google::protobuf::int64 privateKey::dateanchored() const {
  return dateanchored_;
}
inline void privateKey::set_dateanchored(::google::protobuf::int64 value) {
  set_has_dateanchored();
  dateanchored_ = value;
}

// optional string version = 3;
inline bool privateKey::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void privateKey::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void privateKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void privateKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& privateKey::version() const {
  return *version_;
}
inline void privateKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void privateKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void privateKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* privateKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encrKeyData = 4;
inline bool privateKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void privateKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void privateKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void privateKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& privateKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void privateKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void privateKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void privateKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* privateKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes verKeyData = 5;
inline bool privateKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void privateKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void privateKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void privateKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& privateKey::verkeydata() const {
  return *verkeydata_;
}
inline void privateKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void privateKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void privateKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* privateKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentKeyForEmails = 6;
inline int privateKey::currentkeyforemails_size() const {
  return currentkeyforemails_.size();
}
inline void privateKey::clear_currentkeyforemails() {
  currentkeyforemails_.Clear();
}
inline const ::std::string& privateKey::currentkeyforemails(int index) const {
  return currentkeyforemails_.Get(index);
}
inline ::std::string* privateKey::mutable_currentkeyforemails(int index) {
  return currentkeyforemails_.Mutable(index);
}
inline void privateKey::set_currentkeyforemails(int index, const ::std::string& value) {
  currentkeyforemails_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentkeyforemails(int index, const char* value) {
  currentkeyforemails_.Mutable(index)->assign(value);
}
inline void privateKey::set_currentkeyforemails(int index, const char* value, size_t size) {
  currentkeyforemails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_currentkeyforemails() {
  return currentkeyforemails_.Add();
}
inline void privateKey::add_currentkeyforemails(const ::std::string& value) {
  currentkeyforemails_.Add()->assign(value);
}
inline void privateKey::add_currentkeyforemails(const char* value) {
  currentkeyforemails_.Add()->assign(value);
}
inline void privateKey::add_currentkeyforemails(const char* value, size_t size) {
  currentkeyforemails_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::currentkeyforemails() const {
  return currentkeyforemails_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_currentkeyforemails() {
  return &currentkeyforemails_;
}

// repeated string keyForEmails = 7;
inline int privateKey::keyforemails_size() const {
  return keyforemails_.size();
}
inline void privateKey::clear_keyforemails() {
  keyforemails_.Clear();
}
inline const ::std::string& privateKey::keyforemails(int index) const {
  return keyforemails_.Get(index);
}
inline ::std::string* privateKey::mutable_keyforemails(int index) {
  return keyforemails_.Mutable(index);
}
inline void privateKey::set_keyforemails(int index, const ::std::string& value) {
  keyforemails_.Mutable(index)->assign(value);
}
inline void privateKey::set_keyforemails(int index, const char* value) {
  keyforemails_.Mutable(index)->assign(value);
}
inline void privateKey::set_keyforemails(int index, const char* value, size_t size) {
  keyforemails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_keyforemails() {
  return keyforemails_.Add();
}
inline void privateKey::add_keyforemails(const ::std::string& value) {
  keyforemails_.Add()->assign(value);
}
inline void privateKey::add_keyforemails(const char* value) {
  keyforemails_.Add()->assign(value);
}
inline void privateKey::add_keyforemails(const char* value, size_t size) {
  keyforemails_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::keyforemails() const {
  return keyforemails_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_keyforemails() {
  return &keyforemails_;
}

// repeated string keyForDevicesWithUUID = 8;
inline int privateKey::keyfordeviceswithuuid_size() const {
  return keyfordeviceswithuuid_.size();
}
inline void privateKey::clear_keyfordeviceswithuuid() {
  keyfordeviceswithuuid_.Clear();
}
inline const ::std::string& privateKey::keyfordeviceswithuuid(int index) const {
  return keyfordeviceswithuuid_.Get(index);
}
inline ::std::string* privateKey::mutable_keyfordeviceswithuuid(int index) {
  return keyfordeviceswithuuid_.Mutable(index);
}
inline void privateKey::set_keyfordeviceswithuuid(int index, const ::std::string& value) {
  keyfordeviceswithuuid_.Mutable(index)->assign(value);
}
inline void privateKey::set_keyfordeviceswithuuid(int index, const char* value) {
  keyfordeviceswithuuid_.Mutable(index)->assign(value);
}
inline void privateKey::set_keyfordeviceswithuuid(int index, const char* value, size_t size) {
  keyfordeviceswithuuid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_keyfordeviceswithuuid() {
  return keyfordeviceswithuuid_.Add();
}
inline void privateKey::add_keyfordeviceswithuuid(const ::std::string& value) {
  keyfordeviceswithuuid_.Add()->assign(value);
}
inline void privateKey::add_keyfordeviceswithuuid(const char* value) {
  keyfordeviceswithuuid_.Add()->assign(value);
}
inline void privateKey::add_keyfordeviceswithuuid(const char* value, size_t size) {
  keyfordeviceswithuuid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::keyfordeviceswithuuid() const {
  return keyfordeviceswithuuid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_keyfordeviceswithuuid() {
  return &keyfordeviceswithuuid_;
}

// repeated int64 datesCurrentKeysAnchored = 15;
inline int privateKey::datescurrentkeysanchored_size() const {
  return datescurrentkeysanchored_.size();
}
inline void privateKey::clear_datescurrentkeysanchored() {
  datescurrentkeysanchored_.Clear();
}
inline ::google::protobuf::int64 privateKey::datescurrentkeysanchored(int index) const {
  return datescurrentkeysanchored_.Get(index);
}
inline void privateKey::set_datescurrentkeysanchored(int index, ::google::protobuf::int64 value) {
  datescurrentkeysanchored_.Set(index, value);
}
inline void privateKey::add_datescurrentkeysanchored(::google::protobuf::int64 value) {
  datescurrentkeysanchored_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
privateKey::datescurrentkeysanchored() const {
  return datescurrentkeysanchored_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
privateKey::mutable_datescurrentkeysanchored() {
  return &datescurrentkeysanchored_;
}

// optional bytes decrKeyData = 9;
inline bool privateKey::has_decrkeydata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void privateKey::set_has_decrkeydata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void privateKey::clear_has_decrkeydata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void privateKey::clear_decrkeydata() {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    decrkeydata_->clear();
  }
  clear_has_decrkeydata();
}
inline const ::std::string& privateKey::decrkeydata() const {
  return *decrkeydata_;
}
inline void privateKey::set_decrkeydata(const ::std::string& value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void privateKey::set_decrkeydata(const char* value) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(value);
}
inline void privateKey::set_decrkeydata(const void* value, size_t size) {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  decrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_decrkeydata() {
  set_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    decrkeydata_ = new ::std::string;
  }
  return decrkeydata_;
}
inline ::std::string* privateKey::release_decrkeydata() {
  clear_has_decrkeydata();
  if (decrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = decrkeydata_;
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_decrkeydata(::std::string* decrkeydata) {
  if (decrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete decrkeydata_;
  }
  if (decrkeydata) {
    set_has_decrkeydata();
    decrkeydata_ = decrkeydata;
  } else {
    clear_has_decrkeydata();
    decrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signKeyData = 10;
inline bool privateKey::has_signkeydata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void privateKey::set_has_signkeydata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void privateKey::clear_has_signkeydata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void privateKey::clear_signkeydata() {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    signkeydata_->clear();
  }
  clear_has_signkeydata();
}
inline const ::std::string& privateKey::signkeydata() const {
  return *signkeydata_;
}
inline void privateKey::set_signkeydata(const ::std::string& value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void privateKey::set_signkeydata(const char* value) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(value);
}
inline void privateKey::set_signkeydata(const void* value, size_t size) {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  signkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::mutable_signkeydata() {
  set_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    signkeydata_ = new ::std::string;
  }
  return signkeydata_;
}
inline ::std::string* privateKey::release_signkeydata() {
  clear_has_signkeydata();
  if (signkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signkeydata_;
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void privateKey::set_allocated_signkeydata(::std::string* signkeydata) {
  if (signkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete signkeydata_;
  }
  if (signkeydata) {
    set_has_signkeydata();
    signkeydata_ = signkeydata;
  } else {
    clear_has_signkeydata();
    signkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isCompromised = 11;
inline bool privateKey::has_iscompromised() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void privateKey::set_has_iscompromised() {
  _has_bits_[0] |= 0x00000800u;
}
inline void privateKey::clear_has_iscompromised() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void privateKey::clear_iscompromised() {
  iscompromised_ = false;
  clear_has_iscompromised();
}
inline bool privateKey::iscompromised() const {
  return iscompromised_;
}
inline void privateKey::set_iscompromised(bool value) {
  set_has_iscompromised();
  iscompromised_ = value;
}

// optional int64 dateCreated = 12;
inline bool privateKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void privateKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00001000u;
}
inline void privateKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void privateKey::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  clear_has_datecreated();
}
inline ::google::protobuf::int64 privateKey::datecreated() const {
  return datecreated_;
}
inline void privateKey::set_datecreated(::google::protobuf::int64 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// repeated string introducesKeys = 13;
inline int privateKey::introduceskeys_size() const {
  return introduceskeys_.size();
}
inline void privateKey::clear_introduceskeys() {
  introduceskeys_.Clear();
}
inline const ::std::string& privateKey::introduceskeys(int index) const {
  return introduceskeys_.Get(index);
}
inline ::std::string* privateKey::mutable_introduceskeys(int index) {
  return introduceskeys_.Mutable(index);
}
inline void privateKey::set_introduceskeys(int index, const ::std::string& value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void privateKey::set_introduceskeys(int index, const char* value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void privateKey::set_introduceskeys(int index, const char* value, size_t size) {
  introduceskeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_introduceskeys() {
  return introduceskeys_.Add();
}
inline void privateKey::add_introduceskeys(const ::std::string& value) {
  introduceskeys_.Add()->assign(value);
}
inline void privateKey::add_introduceskeys(const char* value) {
  introduceskeys_.Add()->assign(value);
}
inline void privateKey::add_introduceskeys(const char* value, size_t size) {
  introduceskeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::introduceskeys() const {
  return introduceskeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_introduceskeys() {
  return &introduceskeys_;
}

// repeated string isIntroducedByKeys = 14;
inline int privateKey::isintroducedbykeys_size() const {
  return isintroducedbykeys_.size();
}
inline void privateKey::clear_isintroducedbykeys() {
  isintroducedbykeys_.Clear();
}
inline const ::std::string& privateKey::isintroducedbykeys(int index) const {
  return isintroducedbykeys_.Get(index);
}
inline ::std::string* privateKey::mutable_isintroducedbykeys(int index) {
  return isintroducedbykeys_.Mutable(index);
}
inline void privateKey::set_isintroducedbykeys(int index, const ::std::string& value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void privateKey::set_isintroducedbykeys(int index, const char* value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void privateKey::set_isintroducedbykeys(int index, const char* value, size_t size) {
  isintroducedbykeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* privateKey::add_isintroducedbykeys() {
  return isintroducedbykeys_.Add();
}
inline void privateKey::add_isintroducedbykeys(const ::std::string& value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void privateKey::add_isintroducedbykeys(const char* value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void privateKey::add_isintroducedbykeys(const char* value, size_t size) {
  isintroducedbykeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
privateKey::isintroducedbykeys() const {
  return isintroducedbykeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
privateKey::mutable_isintroducedbykeys() {
  return &isintroducedbykeys_;
}

// -------------------------------------------------------------------

// publicKey

// optional string keyLabel = 1;
inline bool publicKey::has_keylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void publicKey::set_has_keylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void publicKey::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void publicKey::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& publicKey::keylabel() const {
  return *keylabel_;
}
inline void publicKey::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void publicKey::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void publicKey::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* publicKey::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 dateAnchored = 2;
inline bool publicKey::has_dateanchored() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void publicKey::set_has_dateanchored() {
  _has_bits_[0] |= 0x00000002u;
}
inline void publicKey::clear_has_dateanchored() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void publicKey::clear_dateanchored() {
  dateanchored_ = GOOGLE_LONGLONG(0);
  clear_has_dateanchored();
}
inline ::google::protobuf::int64 publicKey::dateanchored() const {
  return dateanchored_;
}
inline void publicKey::set_dateanchored(::google::protobuf::int64 value) {
  set_has_dateanchored();
  dateanchored_ = value;
}

// optional string version = 3;
inline bool publicKey::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void publicKey::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void publicKey::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void publicKey::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& publicKey::version() const {
  return *version_;
}
inline void publicKey::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void publicKey::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void publicKey::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* publicKey::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encrKeyData = 4;
inline bool publicKey::has_encrkeydata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void publicKey::set_has_encrkeydata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void publicKey::clear_has_encrkeydata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void publicKey::clear_encrkeydata() {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    encrkeydata_->clear();
  }
  clear_has_encrkeydata();
}
inline const ::std::string& publicKey::encrkeydata() const {
  return *encrkeydata_;
}
inline void publicKey::set_encrkeydata(const ::std::string& value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void publicKey::set_encrkeydata(const char* value) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(value);
}
inline void publicKey::set_encrkeydata(const void* value, size_t size) {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  encrkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_encrkeydata() {
  set_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    encrkeydata_ = new ::std::string;
  }
  return encrkeydata_;
}
inline ::std::string* publicKey::release_encrkeydata() {
  clear_has_encrkeydata();
  if (encrkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrkeydata_;
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_encrkeydata(::std::string* encrkeydata) {
  if (encrkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete encrkeydata_;
  }
  if (encrkeydata) {
    set_has_encrkeydata();
    encrkeydata_ = encrkeydata;
  } else {
    clear_has_encrkeydata();
    encrkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes verKeyData = 5;
inline bool publicKey::has_verkeydata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void publicKey::set_has_verkeydata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void publicKey::clear_has_verkeydata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void publicKey::clear_verkeydata() {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    verkeydata_->clear();
  }
  clear_has_verkeydata();
}
inline const ::std::string& publicKey::verkeydata() const {
  return *verkeydata_;
}
inline void publicKey::set_verkeydata(const ::std::string& value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void publicKey::set_verkeydata(const char* value) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(value);
}
inline void publicKey::set_verkeydata(const void* value, size_t size) {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  verkeydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::mutable_verkeydata() {
  set_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    verkeydata_ = new ::std::string;
  }
  return verkeydata_;
}
inline ::std::string* publicKey::release_verkeydata() {
  clear_has_verkeydata();
  if (verkeydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verkeydata_;
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void publicKey::set_allocated_verkeydata(::std::string* verkeydata) {
  if (verkeydata_ != &::google::protobuf::internal::kEmptyString) {
    delete verkeydata_;
  }
  if (verkeydata) {
    set_has_verkeydata();
    verkeydata_ = verkeydata;
  } else {
    clear_has_verkeydata();
    verkeydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string currentKeyForEmails = 6;
inline int publicKey::currentkeyforemails_size() const {
  return currentkeyforemails_.size();
}
inline void publicKey::clear_currentkeyforemails() {
  currentkeyforemails_.Clear();
}
inline const ::std::string& publicKey::currentkeyforemails(int index) const {
  return currentkeyforemails_.Get(index);
}
inline ::std::string* publicKey::mutable_currentkeyforemails(int index) {
  return currentkeyforemails_.Mutable(index);
}
inline void publicKey::set_currentkeyforemails(int index, const ::std::string& value) {
  currentkeyforemails_.Mutable(index)->assign(value);
}
inline void publicKey::set_currentkeyforemails(int index, const char* value) {
  currentkeyforemails_.Mutable(index)->assign(value);
}
inline void publicKey::set_currentkeyforemails(int index, const char* value, size_t size) {
  currentkeyforemails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_currentkeyforemails() {
  return currentkeyforemails_.Add();
}
inline void publicKey::add_currentkeyforemails(const ::std::string& value) {
  currentkeyforemails_.Add()->assign(value);
}
inline void publicKey::add_currentkeyforemails(const char* value) {
  currentkeyforemails_.Add()->assign(value);
}
inline void publicKey::add_currentkeyforemails(const char* value, size_t size) {
  currentkeyforemails_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::currentkeyforemails() const {
  return currentkeyforemails_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_currentkeyforemails() {
  return &currentkeyforemails_;
}

// repeated string keyForEmails = 7;
inline int publicKey::keyforemails_size() const {
  return keyforemails_.size();
}
inline void publicKey::clear_keyforemails() {
  keyforemails_.Clear();
}
inline const ::std::string& publicKey::keyforemails(int index) const {
  return keyforemails_.Get(index);
}
inline ::std::string* publicKey::mutable_keyforemails(int index) {
  return keyforemails_.Mutable(index);
}
inline void publicKey::set_keyforemails(int index, const ::std::string& value) {
  keyforemails_.Mutable(index)->assign(value);
}
inline void publicKey::set_keyforemails(int index, const char* value) {
  keyforemails_.Mutable(index)->assign(value);
}
inline void publicKey::set_keyforemails(int index, const char* value, size_t size) {
  keyforemails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_keyforemails() {
  return keyforemails_.Add();
}
inline void publicKey::add_keyforemails(const ::std::string& value) {
  keyforemails_.Add()->assign(value);
}
inline void publicKey::add_keyforemails(const char* value) {
  keyforemails_.Add()->assign(value);
}
inline void publicKey::add_keyforemails(const char* value, size_t size) {
  keyforemails_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::keyforemails() const {
  return keyforemails_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_keyforemails() {
  return &keyforemails_;
}

// repeated string keyForDevicesWithUUID = 8;
inline int publicKey::keyfordeviceswithuuid_size() const {
  return keyfordeviceswithuuid_.size();
}
inline void publicKey::clear_keyfordeviceswithuuid() {
  keyfordeviceswithuuid_.Clear();
}
inline const ::std::string& publicKey::keyfordeviceswithuuid(int index) const {
  return keyfordeviceswithuuid_.Get(index);
}
inline ::std::string* publicKey::mutable_keyfordeviceswithuuid(int index) {
  return keyfordeviceswithuuid_.Mutable(index);
}
inline void publicKey::set_keyfordeviceswithuuid(int index, const ::std::string& value) {
  keyfordeviceswithuuid_.Mutable(index)->assign(value);
}
inline void publicKey::set_keyfordeviceswithuuid(int index, const char* value) {
  keyfordeviceswithuuid_.Mutable(index)->assign(value);
}
inline void publicKey::set_keyfordeviceswithuuid(int index, const char* value, size_t size) {
  keyfordeviceswithuuid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_keyfordeviceswithuuid() {
  return keyfordeviceswithuuid_.Add();
}
inline void publicKey::add_keyfordeviceswithuuid(const ::std::string& value) {
  keyfordeviceswithuuid_.Add()->assign(value);
}
inline void publicKey::add_keyfordeviceswithuuid(const char* value) {
  keyfordeviceswithuuid_.Add()->assign(value);
}
inline void publicKey::add_keyfordeviceswithuuid(const char* value, size_t size) {
  keyfordeviceswithuuid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::keyfordeviceswithuuid() const {
  return keyfordeviceswithuuid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_keyfordeviceswithuuid() {
  return &keyfordeviceswithuuid_;
}

// repeated int64 datesCurrentKeysAnchored = 15;
inline int publicKey::datescurrentkeysanchored_size() const {
  return datescurrentkeysanchored_.size();
}
inline void publicKey::clear_datescurrentkeysanchored() {
  datescurrentkeysanchored_.Clear();
}
inline ::google::protobuf::int64 publicKey::datescurrentkeysanchored(int index) const {
  return datescurrentkeysanchored_.Get(index);
}
inline void publicKey::set_datescurrentkeysanchored(int index, ::google::protobuf::int64 value) {
  datescurrentkeysanchored_.Set(index, value);
}
inline void publicKey::add_datescurrentkeysanchored(::google::protobuf::int64 value) {
  datescurrentkeysanchored_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
publicKey::datescurrentkeysanchored() const {
  return datescurrentkeysanchored_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
publicKey::mutable_datescurrentkeysanchored() {
  return &datescurrentkeysanchored_;
}

// optional bool isCompromised = 11;
inline bool publicKey::has_iscompromised() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void publicKey::set_has_iscompromised() {
  _has_bits_[0] |= 0x00000200u;
}
inline void publicKey::clear_has_iscompromised() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void publicKey::clear_iscompromised() {
  iscompromised_ = false;
  clear_has_iscompromised();
}
inline bool publicKey::iscompromised() const {
  return iscompromised_;
}
inline void publicKey::set_iscompromised(bool value) {
  set_has_iscompromised();
  iscompromised_ = value;
}

// optional int64 dateCreated = 12;
inline bool publicKey::has_datecreated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void publicKey::set_has_datecreated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void publicKey::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void publicKey::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  clear_has_datecreated();
}
inline ::google::protobuf::int64 publicKey::datecreated() const {
  return datecreated_;
}
inline void publicKey::set_datecreated(::google::protobuf::int64 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// repeated string introducesKeys = 13;
inline int publicKey::introduceskeys_size() const {
  return introduceskeys_.size();
}
inline void publicKey::clear_introduceskeys() {
  introduceskeys_.Clear();
}
inline const ::std::string& publicKey::introduceskeys(int index) const {
  return introduceskeys_.Get(index);
}
inline ::std::string* publicKey::mutable_introduceskeys(int index) {
  return introduceskeys_.Mutable(index);
}
inline void publicKey::set_introduceskeys(int index, const ::std::string& value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_introduceskeys(int index, const char* value) {
  introduceskeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_introduceskeys(int index, const char* value, size_t size) {
  introduceskeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_introduceskeys() {
  return introduceskeys_.Add();
}
inline void publicKey::add_introduceskeys(const ::std::string& value) {
  introduceskeys_.Add()->assign(value);
}
inline void publicKey::add_introduceskeys(const char* value) {
  introduceskeys_.Add()->assign(value);
}
inline void publicKey::add_introduceskeys(const char* value, size_t size) {
  introduceskeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::introduceskeys() const {
  return introduceskeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_introduceskeys() {
  return &introduceskeys_;
}

// repeated string isIntroducedByKeys = 14;
inline int publicKey::isintroducedbykeys_size() const {
  return isintroducedbykeys_.size();
}
inline void publicKey::clear_isintroducedbykeys() {
  isintroducedbykeys_.Clear();
}
inline const ::std::string& publicKey::isintroducedbykeys(int index) const {
  return isintroducedbykeys_.Get(index);
}
inline ::std::string* publicKey::mutable_isintroducedbykeys(int index) {
  return isintroducedbykeys_.Mutable(index);
}
inline void publicKey::set_isintroducedbykeys(int index, const ::std::string& value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_isintroducedbykeys(int index, const char* value) {
  isintroducedbykeys_.Mutable(index)->assign(value);
}
inline void publicKey::set_isintroducedbykeys(int index, const char* value, size_t size) {
  isintroducedbykeys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* publicKey::add_isintroducedbykeys() {
  return isintroducedbykeys_.Add();
}
inline void publicKey::add_isintroducedbykeys(const ::std::string& value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void publicKey::add_isintroducedbykeys(const char* value) {
  isintroducedbykeys_.Add()->assign(value);
}
inline void publicKey::add_isintroducedbykeys(const char* value, size_t size) {
  isintroducedbykeys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
publicKey::isintroducedbykeys() const {
  return isintroducedbykeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
publicKey::mutable_isintroducedbykeys() {
  return &isintroducedbykeys_;
}

// -------------------------------------------------------------------

// keyExpectation

// optional string fromAddress = 1;
inline bool keyExpectation::has_fromaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void keyExpectation::set_has_fromaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void keyExpectation::clear_has_fromaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void keyExpectation::clear_fromaddress() {
  if (fromaddress_ != &::google::protobuf::internal::kEmptyString) {
    fromaddress_->clear();
  }
  clear_has_fromaddress();
}
inline const ::std::string& keyExpectation::fromaddress() const {
  return *fromaddress_;
}
inline void keyExpectation::set_fromaddress(const ::std::string& value) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(value);
}
inline void keyExpectation::set_fromaddress(const char* value) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(value);
}
inline void keyExpectation::set_fromaddress(const char* value, size_t size) {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  fromaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyExpectation::mutable_fromaddress() {
  set_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    fromaddress_ = new ::std::string;
  }
  return fromaddress_;
}
inline ::std::string* keyExpectation::release_fromaddress() {
  clear_has_fromaddress();
  if (fromaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromaddress_;
    fromaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyExpectation::set_allocated_fromaddress(::std::string* fromaddress) {
  if (fromaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete fromaddress_;
  }
  if (fromaddress) {
    set_has_fromaddress();
    fromaddress_ = fromaddress;
  } else {
    clear_has_fromaddress();
    fromaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string toAddress = 2;
inline bool keyExpectation::has_toaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void keyExpectation::set_has_toaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void keyExpectation::clear_has_toaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void keyExpectation::clear_toaddress() {
  if (toaddress_ != &::google::protobuf::internal::kEmptyString) {
    toaddress_->clear();
  }
  clear_has_toaddress();
}
inline const ::std::string& keyExpectation::toaddress() const {
  return *toaddress_;
}
inline void keyExpectation::set_toaddress(const ::std::string& value) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(value);
}
inline void keyExpectation::set_toaddress(const char* value) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(value);
}
inline void keyExpectation::set_toaddress(const char* value, size_t size) {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  toaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyExpectation::mutable_toaddress() {
  set_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    toaddress_ = new ::std::string;
  }
  return toaddress_;
}
inline ::std::string* keyExpectation::release_toaddress() {
  clear_has_toaddress();
  if (toaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toaddress_;
    toaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyExpectation::set_allocated_toaddress(::std::string* toaddress) {
  if (toaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete toaddress_;
  }
  if (toaddress) {
    set_has_toaddress();
    toaddress_ = toaddress;
  } else {
    clear_has_toaddress();
    toaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 3;
inline bool keyExpectation::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void keyExpectation::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void keyExpectation::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void keyExpectation::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& keyExpectation::version() const {
  return *version_;
}
inline void keyExpectation::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void keyExpectation::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void keyExpectation::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyExpectation::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* keyExpectation::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyExpectation::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string keyLabel = 4;
inline bool keyExpectation::has_keylabel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void keyExpectation::set_has_keylabel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void keyExpectation::clear_has_keylabel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void keyExpectation::clear_keylabel() {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    keylabel_->clear();
  }
  clear_has_keylabel();
}
inline const ::std::string& keyExpectation::keylabel() const {
  return *keylabel_;
}
inline void keyExpectation::set_keylabel(const ::std::string& value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void keyExpectation::set_keylabel(const char* value) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(value);
}
inline void keyExpectation::set_keylabel(const char* value, size_t size) {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  keylabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* keyExpectation::mutable_keylabel() {
  set_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    keylabel_ = new ::std::string;
  }
  return keylabel_;
}
inline ::std::string* keyExpectation::release_keylabel() {
  clear_has_keylabel();
  if (keylabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keylabel_;
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void keyExpectation::set_allocated_keylabel(::std::string* keylabel) {
  if (keylabel_ != &::google::protobuf::internal::kEmptyString) {
    delete keylabel_;
  }
  if (keylabel) {
    set_has_keylabel();
    keylabel_ = keylabel;
  } else {
    clear_has_keylabel();
    keylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 dateCreated = 5;
inline bool keyExpectation::has_datecreated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void keyExpectation::set_has_datecreated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void keyExpectation::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void keyExpectation::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  clear_has_datecreated();
}
inline ::google::protobuf::int64 keyExpectation::datecreated() const {
  return datecreated_;
}
inline void keyExpectation::set_datecreated(::google::protobuf::int64 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// -------------------------------------------------------------------

// plainBackupData

// repeated .mynigma.privateKey privKeys = 1;
inline int plainBackupData::privkeys_size() const {
  return privkeys_.size();
}
inline void plainBackupData::clear_privkeys() {
  privkeys_.Clear();
}
inline const ::mynigma::privateKey& plainBackupData::privkeys(int index) const {
  return privkeys_.Get(index);
}
inline ::mynigma::privateKey* plainBackupData::mutable_privkeys(int index) {
  return privkeys_.Mutable(index);
}
inline ::mynigma::privateKey* plainBackupData::add_privkeys() {
  return privkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >&
plainBackupData::privkeys() const {
  return privkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::privateKey >*
plainBackupData::mutable_privkeys() {
  return &privkeys_;
}

// repeated .mynigma.publicKey pubKeys = 2;
inline int plainBackupData::pubkeys_size() const {
  return pubkeys_.size();
}
inline void plainBackupData::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::mynigma::publicKey& plainBackupData::pubkeys(int index) const {
  return pubkeys_.Get(index);
}
inline ::mynigma::publicKey* plainBackupData::mutable_pubkeys(int index) {
  return pubkeys_.Mutable(index);
}
inline ::mynigma::publicKey* plainBackupData::add_pubkeys() {
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >&
plainBackupData::pubkeys() const {
  return pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::publicKey >*
plainBackupData::mutable_pubkeys() {
  return &pubkeys_;
}

// optional string version = 3;
inline bool plainBackupData::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void plainBackupData::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void plainBackupData::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void plainBackupData::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& plainBackupData::version() const {
  return *version_;
}
inline void plainBackupData::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void plainBackupData::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void plainBackupData::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* plainBackupData::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* plainBackupData::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void plainBackupData::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mynigma.keyExpectation keyExpectations = 4;
inline int plainBackupData::keyexpectations_size() const {
  return keyexpectations_.size();
}
inline void plainBackupData::clear_keyexpectations() {
  keyexpectations_.Clear();
}
inline const ::mynigma::keyExpectation& plainBackupData::keyexpectations(int index) const {
  return keyexpectations_.Get(index);
}
inline ::mynigma::keyExpectation* plainBackupData::mutable_keyexpectations(int index) {
  return keyexpectations_.Mutable(index);
}
inline ::mynigma::keyExpectation* plainBackupData::add_keyexpectations() {
  return keyexpectations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mynigma::keyExpectation >&
plainBackupData::keyexpectations() const {
  return keyexpectations_;
}
inline ::google::protobuf::RepeatedPtrField< ::mynigma::keyExpectation >*
plainBackupData::mutable_keyexpectations() {
  return &keyexpectations_;
}

// optional string integrityCheckString = 5;
inline bool plainBackupData::has_integritycheckstring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void plainBackupData::set_has_integritycheckstring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void plainBackupData::clear_has_integritycheckstring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void plainBackupData::clear_integritycheckstring() {
  if (integritycheckstring_ != &::google::protobuf::internal::kEmptyString) {
    integritycheckstring_->clear();
  }
  clear_has_integritycheckstring();
}
inline const ::std::string& plainBackupData::integritycheckstring() const {
  return *integritycheckstring_;
}
inline void plainBackupData::set_integritycheckstring(const ::std::string& value) {
  set_has_integritycheckstring();
  if (integritycheckstring_ == &::google::protobuf::internal::kEmptyString) {
    integritycheckstring_ = new ::std::string;
  }
  integritycheckstring_->assign(value);
}
inline void plainBackupData::set_integritycheckstring(const char* value) {
  set_has_integritycheckstring();
  if (integritycheckstring_ == &::google::protobuf::internal::kEmptyString) {
    integritycheckstring_ = new ::std::string;
  }
  integritycheckstring_->assign(value);
}
inline void plainBackupData::set_integritycheckstring(const char* value, size_t size) {
  set_has_integritycheckstring();
  if (integritycheckstring_ == &::google::protobuf::internal::kEmptyString) {
    integritycheckstring_ = new ::std::string;
  }
  integritycheckstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* plainBackupData::mutable_integritycheckstring() {
  set_has_integritycheckstring();
  if (integritycheckstring_ == &::google::protobuf::internal::kEmptyString) {
    integritycheckstring_ = new ::std::string;
  }
  return integritycheckstring_;
}
inline ::std::string* plainBackupData::release_integritycheckstring() {
  clear_has_integritycheckstring();
  if (integritycheckstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = integritycheckstring_;
    integritycheckstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void plainBackupData::set_allocated_integritycheckstring(::std::string* integritycheckstring) {
  if (integritycheckstring_ != &::google::protobuf::internal::kEmptyString) {
    delete integritycheckstring_;
  }
  if (integritycheckstring) {
    set_has_integritycheckstring();
    integritycheckstring_ = integritycheckstring;
  } else {
    clear_has_integritycheckstring();
    integritycheckstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// backupPasswordFileWrapper

// optional bytes payloadData = 1;
inline bool backupPasswordFileWrapper::has_payloaddata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void backupPasswordFileWrapper::set_has_payloaddata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void backupPasswordFileWrapper::clear_has_payloaddata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void backupPasswordFileWrapper::clear_payloaddata() {
  if (payloaddata_ != &::google::protobuf::internal::kEmptyString) {
    payloaddata_->clear();
  }
  clear_has_payloaddata();
}
inline const ::std::string& backupPasswordFileWrapper::payloaddata() const {
  return *payloaddata_;
}
inline void backupPasswordFileWrapper::set_payloaddata(const ::std::string& value) {
  set_has_payloaddata();
  if (payloaddata_ == &::google::protobuf::internal::kEmptyString) {
    payloaddata_ = new ::std::string;
  }
  payloaddata_->assign(value);
}
inline void backupPasswordFileWrapper::set_payloaddata(const char* value) {
  set_has_payloaddata();
  if (payloaddata_ == &::google::protobuf::internal::kEmptyString) {
    payloaddata_ = new ::std::string;
  }
  payloaddata_->assign(value);
}
inline void backupPasswordFileWrapper::set_payloaddata(const void* value, size_t size) {
  set_has_payloaddata();
  if (payloaddata_ == &::google::protobuf::internal::kEmptyString) {
    payloaddata_ = new ::std::string;
  }
  payloaddata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* backupPasswordFileWrapper::mutable_payloaddata() {
  set_has_payloaddata();
  if (payloaddata_ == &::google::protobuf::internal::kEmptyString) {
    payloaddata_ = new ::std::string;
  }
  return payloaddata_;
}
inline ::std::string* backupPasswordFileWrapper::release_payloaddata() {
  clear_has_payloaddata();
  if (payloaddata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payloaddata_;
    payloaddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void backupPasswordFileWrapper::set_allocated_payloaddata(::std::string* payloaddata) {
  if (payloaddata_ != &::google::protobuf::internal::kEmptyString) {
    delete payloaddata_;
  }
  if (payloaddata) {
    set_has_payloaddata();
    payloaddata_ = payloaddata;
  } else {
    clear_has_payloaddata();
    payloaddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool hasPassword = 2;
inline bool backupPasswordFileWrapper::has_haspassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void backupPasswordFileWrapper::set_has_haspassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void backupPasswordFileWrapper::clear_has_haspassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void backupPasswordFileWrapper::clear_haspassword() {
  haspassword_ = false;
  clear_has_haspassword();
}
inline bool backupPasswordFileWrapper::haspassword() const {
  return haspassword_;
}
inline void backupPasswordFileWrapper::set_haspassword(bool value) {
  set_has_haspassword();
  haspassword_ = value;
}

// optional string version = 3;
inline bool backupPasswordFileWrapper::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void backupPasswordFileWrapper::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void backupPasswordFileWrapper::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void backupPasswordFileWrapper::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& backupPasswordFileWrapper::version() const {
  return *version_;
}
inline void backupPasswordFileWrapper::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void backupPasswordFileWrapper::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void backupPasswordFileWrapper::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* backupPasswordFileWrapper::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* backupPasswordFileWrapper::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void backupPasswordFileWrapper::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passwordSalt = 6;
inline bool backupPasswordFileWrapper::has_passwordsalt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void backupPasswordFileWrapper::set_has_passwordsalt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void backupPasswordFileWrapper::clear_has_passwordsalt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void backupPasswordFileWrapper::clear_passwordsalt() {
  if (passwordsalt_ != &::google::protobuf::internal::kEmptyString) {
    passwordsalt_->clear();
  }
  clear_has_passwordsalt();
}
inline const ::std::string& backupPasswordFileWrapper::passwordsalt() const {
  return *passwordsalt_;
}
inline void backupPasswordFileWrapper::set_passwordsalt(const ::std::string& value) {
  set_has_passwordsalt();
  if (passwordsalt_ == &::google::protobuf::internal::kEmptyString) {
    passwordsalt_ = new ::std::string;
  }
  passwordsalt_->assign(value);
}
inline void backupPasswordFileWrapper::set_passwordsalt(const char* value) {
  set_has_passwordsalt();
  if (passwordsalt_ == &::google::protobuf::internal::kEmptyString) {
    passwordsalt_ = new ::std::string;
  }
  passwordsalt_->assign(value);
}
inline void backupPasswordFileWrapper::set_passwordsalt(const void* value, size_t size) {
  set_has_passwordsalt();
  if (passwordsalt_ == &::google::protobuf::internal::kEmptyString) {
    passwordsalt_ = new ::std::string;
  }
  passwordsalt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* backupPasswordFileWrapper::mutable_passwordsalt() {
  set_has_passwordsalt();
  if (passwordsalt_ == &::google::protobuf::internal::kEmptyString) {
    passwordsalt_ = new ::std::string;
  }
  return passwordsalt_;
}
inline ::std::string* backupPasswordFileWrapper::release_passwordsalt() {
  clear_has_passwordsalt();
  if (passwordsalt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwordsalt_;
    passwordsalt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void backupPasswordFileWrapper::set_allocated_passwordsalt(::std::string* passwordsalt) {
  if (passwordsalt_ != &::google::protobuf::internal::kEmptyString) {
    delete passwordsalt_;
  }
  if (passwordsalt) {
    set_has_passwordsalt();
    passwordsalt_ = passwordsalt;
  } else {
    clear_has_passwordsalt();
    passwordsalt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mynigma

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_backupData_2eproto__INCLUDED
